<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#f8f9fb">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; worker-src 'self' blob:; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: blob:; connect-src 'self' https:; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self'">
<meta name="description" content="A fast, private, offline-capable PDF reader. Highlight, annotate, bookmark, and read PDFs beautifully on any device.">
<meta property="og:title" content="PDF Reader Pro">
<meta property="og:description" content="A fast, private, offline-capable PDF reader with highlights, annotations, and bookmarks.">
<meta property="og:type" content="website">
<meta property="og:image" content="./icons/icon-512.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PDF Reader Pro">
<meta name="twitter:description" content="A fast, private, offline-capable PDF reader with highlights, annotations, and bookmarks.">
<title>PDF Reader Pro</title>
<link rel="icon" type="image/png" sizes="96x96" href="./icons/icon-96.png">
<link rel="apple-touch-icon" href="./icons/icon-192.png">
<link rel="manifest" href="manifest.json">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="dns-prefetch" href="https://fonts.googleapis.com">
<!-- pdf.js bundled locally for offline/APK use -->
<script src="./lib/pdf.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;0,8..60,700;1,8..60,400&family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }

:root {
  --bg-primary: #f8f9fb;
  --bg-secondary: #eff1f5;
  --bg-tertiary: #e4e7ed;
  --bg-canvas: #ffffff;
  --bg-glass: rgba(248,249,251,0.82);
  --text-primary: #0f172a;
  --text-secondary: #475569;
  --text-tertiary: #94a3b8;
  --accent: #3b82f6;
  --accent-soft: rgba(59,130,246,0.08);
  --accent-hover: #2563eb;
  --accent-glow: rgba(59,130,246,0.2);
  --danger: #ef4444;
  --danger-soft: rgba(239,68,68,0.08);
  --success: #22c55e;
  --border: rgba(0,0,0,0.06);
  --border-strong: rgba(0,0,0,0.1);
  --shadow-xs: 0 1px 2px rgba(0,0,0,0.04);
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
  --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.07), 0 2px 4px -2px rgba(0,0,0,0.05);
  --shadow-lg: 0 10px 25px -5px rgba(0,0,0,0.08), 0 8px 10px -6px rgba(0,0,0,0.04);
  --shadow-xl: 0 20px 50px -12px rgba(0,0,0,0.12);
  --shadow-page: 0 1px 3px rgba(0,0,0,0.06), 0 4px 16px rgba(0,0,0,0.06);
  --radius-sm: 8px;
  --radius-md: 12px;
  --radius-lg: 16px;
  --radius-xl: 24px;
  --radius-full: 9999px;
  --font-ui: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --font-reading: 'Source Serif 4', Georgia, 'Times New Roman', serif;
  --font-mono: 'JetBrains Mono', 'SF Mono', monospace;
  --panel-width: 280px;
  --topbar-height: 56px;
  --statusbar-height: 36px;
  --highlight-yellow: rgba(250,204,21,0.35);
  --highlight-green: rgba(74,222,128,0.30);
  --highlight-blue: rgba(96,165,250,0.30);
  --highlight-pink: rgba(244,114,182,0.30);
  --highlight-purple: rgba(168,85,247,0.30);
  --transition-fast: 120ms cubic-bezier(0.2,0,0,1);
  --transition-smooth: 250ms cubic-bezier(0.2,0,0,1);
  --transition-spring: 400ms cubic-bezier(0.34,1.56,0.64,1);
}

[data-theme="dark"] {
  --bg-primary: #0c0f1a;
  --bg-secondary: #141825;
  --bg-tertiary: #1e2436;
  --bg-canvas: #111624;
  --bg-glass: rgba(12,15,26,0.85);
  --text-primary: #e2e8f0;
  --text-secondary: #94a3b8;
  --text-tertiary: #64748b;
  --accent: #60a5fa;
  --accent-soft: rgba(96,165,250,0.12);
  --accent-hover: #93bbfd;
  --accent-glow: rgba(96,165,250,0.25);
  --border: rgba(255,255,255,0.06);
  --border-strong: rgba(255,255,255,0.1);
  --shadow-xs: 0 1px 2px rgba(0,0,0,0.3);
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.4);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.5);
  --shadow-lg: 0 10px 30px rgba(0,0,0,0.5);
  --shadow-xl: 0 20px 50px rgba(0,0,0,0.6);
  --shadow-page: 0 2px 16px rgba(0,0,0,0.5);
}

[data-theme="sepia"] {
  --bg-primary: #f5efe6;
  --bg-secondary: #ece5d8;
  --bg-tertiary: #ddd4c4;
  --bg-canvas: #faf5ec;
  --bg-glass: rgba(245,239,230,0.85);
  --text-primary: #3c2f20;
  --text-secondary: #6d5d4b;
  --text-tertiary: #9a8c7b;
  --accent: #c2731e;
  --accent-soft: rgba(194,115,30,0.1);
  --accent-hover: #d4842a;
  --accent-glow: rgba(194,115,30,0.2);
  --border: rgba(61,47,32,0.08);
  --border-strong: rgba(61,47,32,0.14);
  --shadow-page: 0 2px 12px rgba(61,47,32,0.08);
}

html, body { 
  height: 100%; 
  overflow: hidden; 
  font-family: var(--font-ui);
  background: var(--bg-primary);
  color: var(--text-primary);
  -webkit-font-smoothing: antialiased;
  -webkit-tap-highlight-color: transparent;
}

#root { height: 100%; }

::selection { background: var(--accent-soft); color: var(--accent); }

::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--text-tertiary); border-radius: 3px; opacity: 0.5; }
::-webkit-scrollbar-thumb:hover { background: var(--text-secondary); }

input, button, textarea { font-family: inherit; }

button { 
  cursor: pointer; 
  border: none; 
  background: none; 
  color: inherit;
  outline: none;
}

button:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
  border-radius: var(--radius-sm);
}

/* ===== ANIMATIONS ===== */
@keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
@keyframes slideUp { from { opacity:0; transform:translateY(16px); } to { opacity:1; transform:translateY(0); } }
@keyframes slideRight { from { opacity:0; transform:translateX(-16px); } to { opacity:1; transform:translateX(0); } }
@keyframes scaleIn { from { opacity:0; transform:scale(0.96); } to { opacity:1; transform:scale(1); } }
@keyframes slideInBottom { from { opacity:0; transform:translateY(100%); } to { opacity:1; transform:translateY(0); } }
@keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:0.5;} }
@keyframes spin { to { transform: rotate(360deg); } }
@keyframes shimmer { 0%{background-position:-200% 0;} 100%{background-position:200% 0;} }
@keyframes glow { 0%,100%{box-shadow:0 0 0 0 var(--accent-glow);} 50%{box-shadow:0 0 0 8px transparent;} }

.animate-fade { animation: fadeIn 0.25s cubic-bezier(0.2,0,0,1); }
.animate-slide-up { animation: slideUp 0.35s cubic-bezier(0.2,0,0,1); }
.animate-scale { animation: scaleIn 0.2s cubic-bezier(0.2,0,0,1); }

/* ===== APP SHELL ===== */
.app-shell {
  height: 100%;
  display: flex;
  flex-direction: column;
  background: var(--bg-primary);
  position: relative;
  overflow: hidden;
}

/* ===== LIBRARY ===== */
.library {
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.library-header {
  padding: 24px 24px 0;
  flex-shrink: 0;
}

.library-brand {
  display: flex;
  align-items: center;
  gap: 14px;
  margin-bottom: 28px;
}

.library-logo {
  width: 44px;
  height: 44px;
  background: linear-gradient(135deg, #3b82f6, #8b5cf6);
  border-radius: var(--radius-md);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 800;
  font-size: 20px;
  letter-spacing: -1px;
  box-shadow: 0 4px 12px rgba(59,130,246,0.3), 0 0 0 1px rgba(255,255,255,0.1) inset;
}

.library-title {
  font-size: 24px;
  font-weight: 800;
  letter-spacing: -0.6px;
  color: var(--text-primary);
  line-height: 1.1;
}

.library-subtitle {
  font-size: 12px;
  color: var(--text-tertiary);
  font-weight: 500;
  letter-spacing: 0.3px;
  margin-top: 2px;
}

.library-actions {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.lib-btn {
  padding: 12px 20px;
  border-radius: var(--radius-md);
  font-size: 14px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  transition: all var(--transition-fast);
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

.lib-btn-primary {
  flex: 1;
  background: var(--accent);
  color: white;
  box-shadow: 0 2px 8px var(--accent-glow), 0 1px 2px rgba(0,0,0,0.06);
}

.lib-btn-primary:hover { background: var(--accent-hover); transform: translateY(-1px); box-shadow: 0 4px 12px var(--accent-glow); }
.lib-btn-primary:active { background: var(--accent-hover); transform: scale(0.97); box-shadow: none; }

.lib-btn-secondary {
  background: var(--bg-secondary);
  color: var(--text-secondary);
  border: 1px solid var(--border);
  padding: 12px;
}

.lib-btn-secondary:hover { background: var(--bg-tertiary); color: var(--text-primary); }
.lib-btn-secondary:active { background: var(--bg-tertiary); transform: scale(0.95); }

.library-search {
  position: relative;
  margin-bottom: 16px;
}

.library-search input {
  width: 100%;
  padding: 11px 16px 11px 42px;
  background: var(--bg-secondary);
  border: 1.5px solid var(--border);
  border-radius: var(--radius-full);
  font-size: 14px;
  color: var(--text-primary);
  transition: all var(--transition-fast);
}

.library-search input:focus {
  border-color: var(--accent);
  background: var(--bg-canvas);
  box-shadow: 0 0 0 3px var(--accent-soft);
  outline: none;
}

.library-search input::placeholder { color: var(--text-tertiary); }

.library-search svg {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--text-tertiary);
}

.library-tabs {
  display: flex;
  gap: 4px;
  padding: 4px;
  background: var(--bg-secondary);
  border-radius: var(--radius-md);
  margin-bottom: 16px;
}

.lib-tab {
  flex: 1;
  padding: 8px 12px;
  font-size: 13px;
  font-weight: 500;
  border-radius: var(--radius-sm);
  color: var(--text-tertiary);
  transition: all var(--transition-fast);
}

.lib-tab.active {
  background: var(--bg-canvas);
  color: var(--text-primary);
  box-shadow: var(--shadow-sm);
}

.library-content {
  flex: 1;
  overflow-y: auto;
  padding: 0 24px 24px;
}

.library-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
  gap: 16px;
}

.doc-card {
  background: var(--bg-canvas);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  overflow: hidden;
  cursor: pointer;
  position: relative;
}

.doc-card:hover {
  transform: translateY(-6px);
  box-shadow: var(--shadow-xl);
  border-color: rgba(59,130,246,0.3);
}

.doc-card:active {
  transform: translateY(-2px) scale(0.99);
  box-shadow: var(--shadow-md);
}

.doc-card-thumb {
  height: 180px;
  background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
}

.doc-card-thumb canvas {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.doc-card-thumb .thumb-placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  color: var(--text-tertiary);
}

.doc-card-thumb .thumb-placeholder svg { opacity: 0.4; }

.doc-card-progress {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: var(--border);
}

.doc-card-progress-bar {
  height: 100%;
  background: var(--accent);
  border-radius: 0 2px 2px 0;
  transition: width 0.5s ease;
}

.doc-card-info {
  padding: 14px;
}

.doc-card-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-primary);
  line-height: 1.35;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  margin-bottom: 6px;
  letter-spacing: -0.1px;
}

.doc-card-meta {
  font-size: 11px;
  color: var(--text-tertiary);
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: 500;
}

/* Empty state */
.library-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 80px 24px;
  text-align: center;
  animation: slideUp 0.5s cubic-bezier(0.2,0,0,1);
}

.library-empty-icon {
  width: 88px;
  height: 88px;
  background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
  border-radius: var(--radius-xl);
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 24px;
  color: var(--text-tertiary);
  box-shadow: var(--shadow-sm);
}

.library-empty h3 {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 8px;
  letter-spacing: -0.3px;
}

.library-empty p {
  font-size: 14px;
  color: var(--text-tertiary);
  max-width: 300px;
  line-height: 1.6;
}

/* Drop zone */
.drop-zone-overlay {
  position: fixed;
  inset: 0;
  background: rgba(45,91,227,0.08);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  animation: fadeIn 0.2s ease;
}

.drop-zone-box {
  padding: 52px 72px;
  border: 2px dashed var(--accent);
  border-radius: var(--radius-xl);
  background: var(--bg-canvas);
  text-align: center;
  box-shadow: var(--shadow-xl);
  animation: scaleIn 0.25s cubic-bezier(0.34,1.56,0.64,1);
}

.drop-zone-box svg { color: var(--accent); margin-bottom: 16px; }
.drop-zone-box h3 { font-size: 20px; font-weight: 700; margin-bottom: 6px; letter-spacing: -0.3px; }
.drop-zone-box p { font-size: 14px; color: var(--text-tertiary); }

/* ===== READER ===== */
.reader-shell {
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Top Bar */
.reader-topbar {
  height: var(--topbar-height);
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border);
  box-shadow: 0 1px 3px rgba(0,0,0,0.04);
  display: flex;
  align-items: center;
  padding: 0 8px;
  gap: 2px;
  flex-shrink: 0;
  z-index: 100;
}

.reader-topbar.hidden {
  opacity: 0;
  pointer-events: none;
  transform: translateY(-100%);
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}

.topbar-btn {
  width: 40px;
  height: 40px;
  min-width: 40px;
  min-height: 40px;
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  transition: background var(--transition-fast), color var(--transition-fast);
  flex-shrink: 0;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  position: relative;
}

.topbar-btn:hover { background: var(--bg-secondary); color: var(--text-primary); }
.topbar-btn:active { background: var(--bg-tertiary); color: var(--text-primary); transform: scale(0.9); }
.topbar-btn.active { background: var(--accent-soft); color: var(--accent); }
.topbar-btn.active:active { background: var(--accent-soft); transform: scale(0.9); }
.topbar-btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  transform: none !important;
}

.topbar-sep {
  width: 1px;
  height: 20px;
  background: var(--border-strong);
  margin: 0 4px;
  flex-shrink: 0;
}

.topbar-title {
  flex: 1;
  min-width: 0;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: center;
  letter-spacing: -0.2px;
  padding: 0 4px;
}

/* Reader Body */
.reader-body {
  flex: 1;
  display: flex;
  overflow: hidden;
  position: relative;
}

/* Side Panel */
.side-panel {
  width: var(--panel-width);
  background: var(--bg-primary);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  flex-shrink: 0;
  animation: slideRight 0.25s cubic-bezier(0.2,0,0,1);
}

.side-panel-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
  padding: 8px 8px 0;
  gap: 2px;
}

.sp-tab {
  padding: 8px 12px;
  font-size: 12px;
  font-weight: 600;
  color: var(--text-tertiary);
  border-bottom: 2px solid transparent;
  transition: all var(--transition-fast);
  white-space: nowrap;
}

.sp-tab:hover { color: var(--text-secondary); }
.sp-tab:active { transform: scale(0.95); }
.sp-tab.active { color: var(--accent); border-bottom-color: var(--accent); }

.side-panel-content {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}

/* Thumbnails */
.thumb-grid {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.thumb-item {
  background: var(--bg-canvas);
  border: 2px solid var(--border);
  border-radius: var(--radius-md);
  padding: 4px;
  cursor: pointer;
  transition: all var(--transition-fast);
  display: flex;
  align-items: center;
  gap: 8px;
}

.thumb-item:hover { border-color: var(--accent); }
.thumb-item.active { border-color: var(--accent); background: var(--accent-soft); }

.thumb-item canvas {
  width: 60px;
  height: 80px;
  object-fit: contain;
  border-radius: 4px;
  flex-shrink: 0;
}

.thumb-label {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
}

/* Outline */
.outline-item {
  padding: 8px 10px;
  font-size: 13px;
  color: var(--text-secondary);
  cursor: pointer;
  border-radius: var(--radius-sm);
  transition: all var(--transition-fast);
  border-left: 2px solid transparent;
}

.outline-item:hover { background: var(--bg-secondary); color: var(--text-primary); }
.outline-item.active { border-left-color: var(--accent); color: var(--accent); background: var(--accent-soft); }

.outline-item-l1 { padding-left: 10px; font-weight: 600; }
.outline-item-l2 { padding-left: 24px; }
.outline-item-l3 { padding-left: 38px; font-size: 12px; }

/* Bookmarks */
.bookmark-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.bookmark-item:hover { background: var(--bg-secondary); }

.bookmark-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--accent);
  flex-shrink: 0;
}

.bookmark-info {
  flex: 1;
  min-width: 0;
}

.bookmark-page {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-primary);
}

.bookmark-label {
  font-size: 11px;
  color: var(--text-tertiary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.bookmark-remove {
  opacity: 0;
  transition: opacity var(--transition-fast);
}

.bookmark-item:hover .bookmark-remove { opacity: 1; }

/* Annotations Panel */
.annotation-item {
  padding: 10px;
  border-radius: var(--radius-md);
  margin-bottom: 6px;
  cursor: pointer;
  transition: all var(--transition-fast);
  border-left: 3px solid;
}

.annotation-item:hover { background: var(--bg-secondary); }

.annotation-text {
  font-size: 13px;
  color: var(--text-primary);
  line-height: 1.4;
  font-family: var(--font-reading);
  margin-bottom: 4px;
}

.annotation-meta {
  font-size: 11px;
  color: var(--text-tertiary);
}

/* Reading Canvas */
.reading-canvas {
  flex: 1;
  overflow: auto;
  background: #e8e8ec;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  overscroll-behavior-y: contain;
  padding-bottom: env(safe-area-inset-bottom, 0px);
}
[data-theme="dark"] .reading-canvas { background: #1a1d23; }
[data-theme="sepia"] .reading-canvas { background: #ddd4c4; }

.page-container {
  padding: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  min-height: 100%;
  flex-shrink: 0;
  width: 100%;
}

.page-container.zoom-preview {
  will-change: transform;
  transform: scale(var(--zoom-preview-ratio, 1));
  transform-origin: var(--zoom-anchor-x, 50%) var(--zoom-anchor-y, 50%);
  transition: transform 45ms linear;
}

.page-wrapper {
  position: relative;
  box-shadow: 0 1px 4px rgba(0,0,0,0.08), 0 0 0 1px rgba(0,0,0,0.04);
  border-radius: 3px;
  overflow: hidden;
  background: white;
  flex-shrink: 0;
  margin: 0 auto;
}
@media (min-width: 769px) {
  .page-wrapper {
    box-shadow: 0 2px 12px rgba(0,0,0,0.1), 0 0 0 1px rgba(0,0,0,0.06);
  }
}

.page-wrapper canvas {
  display: block;
}

[data-theme="dark"] .page-wrapper { background: #faf9f7; }
[data-theme="sepia"] .page-wrapper { background: #fefcf7; }

.page-number-label {
  text-align: center;
  font-size: 11px;
  color: var(--text-tertiary);
  padding: 4px 0 8px;
  font-variant-numeric: tabular-nums;
  font-weight: 500;
}

/* Text selection layer */
.text-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  overflow: hidden;
  line-height: 1;
  z-index: 2;
  -webkit-touch-callout: default;
  -webkit-user-select: text;
  user-select: text;
  touch-action: auto;
}

.text-layer span {
  position: absolute;
  white-space: pre;
  transform-origin: 0% 0%;
  color: transparent;
  padding: 2px 0;
  min-height: 1em;
}

.text-layer span::selection {
  background: rgba(59,130,246,0.35);
  color: transparent;
}

@media (pointer: coarse) {
  .text-layer span { padding: 3px 0; }
  .text-layer span::selection { background: rgba(59,130,246,0.4); }
}

/* Highlight overlays */
.highlight-overlay {
  position: absolute;
  pointer-events: none;
  border-radius: 2px;
}

/* Search highlights on page */
.search-page-highlight {
  position: absolute;
  background: rgba(255, 213, 0, 0.4);
  border: 1px solid rgba(255, 180, 0, 0.6);
  border-radius: 2px;
  pointer-events: none;
  z-index: 6;
  mix-blend-mode: multiply;
}
[data-theme="dark"] .search-page-highlight { mix-blend-mode: screen; background: rgba(255, 200, 0, 0.25); }

/* Note pins — sticky-note icons placed on the page */
.note-pin {
  position: absolute;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  pointer-events: auto;
  z-index: 10;
  transition: transform 0.15s, box-shadow 0.15s;
  box-shadow: var(--shadow-sm);
  border: 2px solid rgba(255,255,255,0.9);
}
.note-pin:hover { transform: scale(1.2); box-shadow: var(--shadow-md); }
.note-pin svg { width: 14px; height: 14px; color: #fff; flex-shrink: 0; }

/* Note popover — shown when clicking a pin */
.note-popover {
  position: absolute;
  z-index: 100;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-lg);
  padding: 12px;
  width: 240px;
  max-height: 200px;
  overflow-y: auto;
  font-family: var(--font-ui);
  font-size: 13px;
  color: var(--text-primary);
  pointer-events: auto;
}
.note-popover-text { margin-bottom: 8px; white-space: pre-wrap; word-break: break-word; line-height: 1.5; }
.note-popover-quote { font-size: 11px; color: var(--text-tertiary); font-style: italic; border-left: 2px solid var(--border-strong); padding-left: 8px; margin-bottom: 8px; }
.note-popover-actions { display: flex; gap: 8px; justify-content: flex-end; }
.note-popover-actions button { font-size: 11px; padding: 4px 10px; border-radius: var(--radius-sm); cursor: pointer; font-family: var(--font-ui); font-weight: 500; }
.note-popover .btn-delete { background: var(--danger-soft); color: var(--danger); }
.note-popover .btn-delete:hover { background: var(--danger); color: white; }
.note-popover .btn-close { background: var(--bg-secondary); color: var(--text-secondary); }

/* Note mode cursor */
.reading-canvas.note-mode { cursor: crosshair; }
.reading-canvas.note-mode .page-wrapper { cursor: crosshair; }

/* Highlight overlay — clickable */
.highlight-overlay { pointer-events: none; }
.highlight-overlay[data-anno-id] { pointer-events: auto; cursor: pointer; }

/* Annotation Popover (click highlight to edit/delete) */
.anno-popover {
  position: fixed;
  z-index: 9999;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-lg);
  padding: 8px 10px;
  display: flex;
  align-items: center;
  gap: 8px;
  animation: scaleIn 0.15s cubic-bezier(0.2,0,0,1);
}
.anno-popover-colors { display: flex; gap: 5px; align-items: center; }
.anno-popover-color {
  width: 18px; height: 18px; border-radius: 50%;
  border: 2px solid transparent;
  cursor: pointer;
  transition: transform 0.12s cubic-bezier(0.34,1.56,0.64,1), border-color 0.1s;
  flex-shrink: 0;
}
.anno-popover-color:hover { transform: scale(1.3); }
.anno-popover-color.active { border-color: var(--text-primary); }
.anno-popover-sep { width: 1px; height: 18px; background: var(--border-strong); flex-shrink: 0; }
.anno-popover-del {
  color: var(--danger); padding: 4px 6px; border-radius: 6px;
  font-size: 12px; font-weight: 600; cursor: pointer;
  transition: background var(--transition-fast);
  flex-shrink: 0;
}
.anno-popover-del:hover { background: var(--danger-soft); }

/* Long-press context toolbar */
.selection-toolbar {
  position: fixed;
  z-index: 9998;
  display: flex;
  gap: 2px;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-lg);
  padding: 4px;
  animation: scaleIn 0.15s cubic-bezier(0.2,0,0,1);
  transition: opacity 0.15s ease;
}
.selection-toolbar button {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 8px 12px;
  border-radius: var(--radius-sm);
  font-family: var(--font-ui);
  font-size: 12px;
  font-weight: 500;
  color: var(--text-primary);
  white-space: nowrap;
  cursor: pointer;
  min-height: 44px;
  transition: background 0.15s;
}
.selection-toolbar button:hover { background: var(--bg-secondary); }
.selection-toolbar button:active { background: var(--bg-tertiary); }
.selection-toolbar button svg { flex-shrink: 0; }

/* Status Bar */
.reader-statusbar {
  height: var(--statusbar-height);
  background: var(--bg-primary);
  border-top: 1px solid var(--border);
  box-shadow: 0 -1px 3px rgba(0,0,0,0.03);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-tertiary);
  font-variant-numeric: tabular-nums;
  flex-shrink: 0;
  z-index: 100;
}

.reader-statusbar.hidden { opacity: 0; pointer-events: none; }

.status-left, .status-right { display: flex; align-items: center; gap: 8px; }

.status-nav-btn {
  width: 44px;
  height: 44px;
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  transition: background var(--transition-fast), color var(--transition-fast);
  flex-shrink: 0;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}
.status-nav-btn:hover { background: var(--bg-secondary); color: var(--text-primary); }
.status-nav-btn:active { background: var(--bg-tertiary); transform: scale(0.88); }
.status-nav-btn:disabled { opacity: 0.3; pointer-events: none; }

.page-jump-display {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 6px;
  transition: background var(--transition-fast);
  user-select: none;
  min-height: 32px;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}
.page-jump-display:hover { background: var(--bg-secondary); color: var(--text-primary); }

.page-jump-input {
  width: 40px;
  text-align: center;
  background: var(--bg-secondary);
  border: 1.5px solid var(--accent);
  border-radius: 4px;
  font-size: 11px;
  font-weight: 700;
  color: var(--text-primary);
  padding: 2px 4px;
  outline: none;
  font-family: var(--font-ui);
  font-variant-numeric: tabular-nums;
}
.page-jump-input:focus { box-shadow: 0 0 0 3px var(--accent-soft); }

.status-divider {
  width: 1px;
  height: 12px;
  background: var(--border-strong);
}

/* Page Slider */
.page-slider-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
}

.page-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 120px;
  height: 4px;
  background: var(--bg-tertiary);
  border-radius: var(--radius-full);
  outline: none;
}

.page-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: var(--radius-full);
  background: var(--accent);
  cursor: pointer;
  box-shadow: 0 1px 4px var(--accent-glow), 0 1px 2px rgba(0,0,0,0.1);
  transition: transform 0.15s ease;
}

.page-slider::-webkit-slider-thumb:hover {
  transform: scale(1.15);
}

.page-slider:active::-webkit-slider-thumb {
  transform: scale(1.2);
}

/* ===== SEARCH OVERLAY ===== */
.search-overlay {
  position: absolute;
  top: calc(var(--topbar-height) + 4px);
  right: 12px;
  width: 340px;
  max-height: 420px;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-xl);
  z-index: 200;
  display: flex;
  flex-direction: column;
  animation: scaleIn 0.2s cubic-bezier(0.2,0,0,1);
  overflow: hidden;
}

.search-input-wrap {
  padding: 12px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 8px;
}

.search-input-wrap input {
  flex: 1;
  border: none;
  background: transparent;
  font-size: 14px;
  color: var(--text-primary);
  outline: none;
}

.search-input-wrap input::placeholder { color: var(--text-tertiary); }

.search-results {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.search-result-item {
  padding: 8px 10px;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: background var(--transition-fast);
}

.search-result-item:hover { background: var(--bg-secondary); }
.search-result-item.active { background: var(--accent-soft); }

.search-result-page {
  font-size: 11px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 2px;
}

.search-result-context {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.4;
}

.search-result-context mark {
  background: var(--highlight-yellow);
  color: inherit;
  border-radius: 2px;
  padding: 0 2px;
}

.search-count {
  padding: 8px 12px;
  font-size: 11px;
  color: var(--text-tertiary);
  border-top: 1px solid var(--border);
}

/* ===== ANNOTATION FAB & MENU ===== */
.anno-fab {
  position: fixed;
  bottom: 28px;
  right: 24px;
  width: 56px;
  height: 56px;
  border-radius: var(--radius-full);
  background: linear-gradient(135deg, var(--accent), #6366f1);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 14px var(--accent-glow), 0 2px 6px rgba(0,0,0,0.1);
  z-index: 300;
  transition: all var(--transition-fast);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}
.anno-fab:hover { transform: scale(1.06); box-shadow: 0 6px 20px var(--accent-glow), 0 3px 10px rgba(0,0,0,0.1); }
.anno-fab:active { transform: scale(0.92); box-shadow: 0 2px 6px var(--accent-glow); }
.anno-fab.active { background: var(--text-primary); box-shadow: var(--shadow-lg); }

.anno-menu {
  position: fixed;
  bottom: 96px;
  right: 24px;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-lg);
  padding: 6px;
  display: flex;
  flex-direction: column;
  gap: 2px;
  box-shadow: var(--shadow-xl);
  z-index: 300;
  animation: slideUp 0.2s cubic-bezier(0.2,0,0,1);
  min-width: 52px;
}

.anno-btn {
  width: 48px;
  height: 46px;
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  transition: all var(--transition-fast);
  position: relative;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

.anno-btn:hover { background: var(--bg-secondary); color: var(--text-primary); }
.anno-btn:active { background: var(--bg-tertiary); transform: scale(0.92); }
.anno-btn.active { background: var(--accent-soft); color: var(--accent); }
.anno-btn.active:active { transform: scale(0.92); }

.anno-color-row {
  display: flex;
  gap: 4px;
  padding: 6px 4px;
  justify-content: center;
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  margin: 2px 0;
}

.color-dot {
  width: 24px;
  height: 24px;
  border-radius: var(--radius-full);
  border: 2.5px solid transparent;
  transition: all var(--transition-fast);
  cursor: pointer;
}

.color-dot:hover { transform: scale(1.15); }
.color-dot:active { transform: scale(0.88); }
.color-dot.active { border-color: var(--text-primary); box-shadow: 0 0 0 2px var(--bg-canvas); }

.anno-label {
  font-size: 10px;
  text-align: center;
  color: var(--text-tertiary);
  margin-top: -2px;
}

/* ===== CONTEXT MENU ===== */
.context-menu {
  position: fixed;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-lg);
  z-index: 400;
  min-width: 180px;
  padding: 6px;
  animation: scaleIn 0.15s ease;
}

.ctx-item {
  padding: 8px 12px;
  font-size: 13px;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 10px;
  border-radius: var(--radius-sm);
  transition: all var(--transition-fast);
  width: 100%;
  text-align: left;
}

.ctx-item:hover { background: var(--bg-secondary); color: var(--text-primary); }
.ctx-item svg { flex-shrink: 0; }

/* ===== SETTINGS MODAL ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.15s cubic-bezier(0.2,0,0,1);
}

.modal-content {
  width: 90%;
  max-width: 440px;
  max-height: 80vh;
  background: var(--bg-canvas);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-xl);
  overflow: hidden;
  animation: scaleIn 0.25s cubic-bezier(0.34,1.56,0.64,1);
  display: flex;
  flex-direction: column;
  border: 1px solid var(--border);
}

.modal-header {
  padding: 20px 24px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.modal-header h2 {
  font-size: 18px;
  font-weight: 700;
  letter-spacing: -0.3px;
}

.modal-body {
  padding: 20px 24px;
  overflow-y: auto;
  flex: 1;
}

.setting-group {
  margin-bottom: 24px;
}

.setting-group-title {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 12px;
}

.setting-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 0;
}

.setting-label {
  font-size: 14px;
  color: var(--text-primary);
}

.setting-desc {
  font-size: 12px;
  color: var(--text-tertiary);
}

/* Toggle Switch */
.toggle {
  width: 44px;
  height: 24px;
  background: var(--bg-tertiary);
  border-radius: 12px;
  position: relative;
  cursor: pointer;
  transition: background var(--transition-fast);
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

.toggle.active { background: var(--accent); }
.toggle:active { transform: scale(0.95); }

.toggle::after {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 20px;
  height: 20px;
  background: white;
  border-radius: 50%;
  transition: transform var(--transition-fast);
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.toggle.active::after { transform: translateX(20px); }

/* Zoom Presets */
.zoom-presets {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}
.zoom-preset-btn {
  padding: 5px 10px;
  border-radius: var(--radius-sm);
  font-size: 12px;
  font-weight: 600;
  background: var(--bg-secondary);
  color: var(--text-secondary);
  border: 1.5px solid var(--border);
  cursor: pointer;
  transition: all var(--transition-fast);
}
.zoom-preset-btn:hover { background: var(--bg-tertiary); color: var(--text-primary); border-color: var(--border-strong); }
.zoom-preset-btn.active { background: var(--accent-soft); color: var(--accent); border-color: var(--accent); }

/* Theme Picker */
.theme-picker {
  display: flex;
  gap: 10px;
}

.theme-option {
  flex: 1;
  height: 52px;
  border-radius: var(--radius-md);
  border: 2px solid var(--border);
  cursor: pointer;
  transition: all var(--transition-fast);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: 600;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

.theme-option:hover { border-color: var(--text-tertiary); }
.theme-option:active { transform: scale(0.95); }
.theme-option.active { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-soft); }

.theme-light { background: #f8f9fb; color: #0f172a; }
.theme-dark { background: #0c0f1a; color: #e2e8f0; }
.theme-sepia { background: #f5efe6; color: #3c2f20; }

/* ===== FOCUS MODE ===== */
.focus-mode .reader-topbar,
.focus-mode .reader-statusbar,
.focus-mode .side-panel {
  opacity: 0;
  pointer-events: none;
}

.focus-mode .reading-canvas {
  background: #111113;
}
[data-theme="sepia"] .focus-mode .reading-canvas { background: #2a2117; }

.focus-mode .page-container {
  padding-top: 40px;
}

/* ===== LOADING ===== */
.loading-wrap {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 80px 40px;
  gap: 20px;
  color: var(--text-tertiary);
  font-size: 14px;
  font-weight: 500;
}

.spinner {
  width: 36px;
  height: 36px;
  border: 3px solid var(--border-strong);
  border-top-color: var(--accent);
  border-radius: var(--radius-full);
  animation: spin 0.7s linear infinite;
}

/* ===== TOAST ===== */
.toast {
  position: fixed;
  bottom: 100px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--text-primary);
  color: var(--bg-canvas);
  padding: 12px 24px;
  border-radius: var(--radius-full);
  font-size: 13px;
  font-weight: 600;
  letter-spacing: -0.1px;
  box-shadow: var(--shadow-xl);
  z-index: 600;
  animation: slideUp 0.35s cubic-bezier(0.34,1.56,0.64,1);
  pointer-events: none;
  white-space: nowrap;
}

/* ===== READING RULER ===== */
.reading-ruler {
  position: fixed;
  left: 0;
  right: 0;
  height: 2px;
  background: var(--accent);
  opacity: 0.3;
  pointer-events: none;
  z-index: 50;
  transition: top 0.1s ease;
}

/* ===== DRAWING CANVAS ===== */
.drawing-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  cursor: crosshair;
  z-index: 10;
  touch-action: none;
}

/* ===== DOC CARD DELETE ===== */
.doc-card-delete {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 30px;
  height: 30px;
  border-radius: var(--radius-full);
  background: rgba(255,255,255,0.9);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid rgba(0,0,0,0.08);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-tertiary);
  opacity: 0;
  transition: all var(--transition-fast);
  z-index: 2;
}
.doc-card:hover .doc-card-delete { opacity: 1; }
.doc-card-delete:hover { color: var(--danger); background: var(--danger-soft); border-color: var(--danger); }
.doc-card-delete:active { transform: scale(0.85); }

@media (hover: none) {
  .doc-card-delete { opacity: 0.8; }
}

.doc-card-thumb { position: relative; }

/* ===== LOADING PROGRESS ===== */
.load-progress {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  z-index: 200;
  background: var(--border);
}
.load-progress-bar {
  height: 100%;
  background: var(--accent);
  transition: width 0.4s cubic-bezier(0.2,0,0,1);
  border-radius: 0 2px 2px 0;
}

/* ===== SIDEBAR BACKDROP (mobile) ===== */
.sidebar-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  z-index: 149;
  animation: fadeIn 0.2s ease;
}

/* ===== PAGE PLACEHOLDER ===== */
.page-placeholder {
  background: var(--bg-canvas);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-tertiary);
  font-size: 13px;
  font-weight: 500;
  font-variant-numeric: tabular-nums;
  opacity: 0.6;
}

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  :root {
    --topbar-height: 50px;
    --panel-width: 260px;
  }

  /* Side panel: overlay on mobile */
  .side-panel {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    z-index: 150;
    box-shadow: var(--shadow-xl);
  }

  .sidebar-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.4);
    z-index: 140;
  }

  /* Library */
  .library-header { padding: 20px 16px 0; }
  .library-brand { margin-bottom: 20px; }
  .library-title { font-size: 22px; }
  .library-grid {
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 12px;
    padding: 0 16px 16px;
  }
  .library-actions { margin-bottom: 16px; }
  .lib-btn { padding: 11px 14px; font-size: 13px; }
  .drop-zone-box { padding: 32px 24px; }
  .doc-card-thumb { height: 160px; }

  /* Reader topbar: compact layout */
  .reader-topbar {
    padding: env(safe-area-inset-top, 0px) 4px 0 4px;
    gap: 0;
    flex-wrap: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
    scrollbar-width: none;
  }
  .reader-topbar::-webkit-scrollbar { display: none; }
  .topbar-btn { min-width: 44px; min-height: 44px; width: 44px; height: 44px; }
  .topbar-sep { margin: 0; height: 16px; }
  .topbar-title { font-size: 13px; min-width: 30px; padding: 0 2px; }
  #zoom-display { font-size: 11px; min-width: 32px; }

  /* Reading canvas: less padding */
  .page-container { padding: 8px; gap: 12px; }
  /* Lightweight page edge on mobile (no box-shadow paint cost) */
  .page-wrapper { box-shadow: none; }

  /* Search overlay: full width */
  .search-overlay {
    width: calc(100% - 16px);
    right: 8px;
    top: calc(var(--topbar-height) + 4px + env(safe-area-inset-top, 0px));
  }

  /* Annotation FAB: adjust for safe area */
  .anno-fab {
    bottom: calc(20px + env(safe-area-inset-bottom, 0px));
    right: 16px;
    width: 52px;
    height: 52px;
  }
  .anno-menu {
    bottom: calc(82px + env(safe-area-inset-bottom, 0px));
    right: 16px;
  }

  /* Status bar — taller on mobile for touch targets */
  .reader-statusbar {
    height: 44px;
    padding: 0 12px;
    padding-bottom: env(safe-area-inset-bottom, 0px);
    font-size: 10px;
  }
  .status-left, .status-right { gap: 6px; }
  .status-nav-btn { width: 36px; height: 36px; }
  .page-slider { width: 80px; }

  /* Modal: bottom sheet style on mobile */
  .modal-overlay { align-items: flex-end; }
  .modal-content {
    width: 100%;
    max-width: 100%;
    max-height: 85vh;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
    animation: slideInBottom 0.3s cubic-bezier(0.2,0,0,1);
  }
}

/* Extra small screens (phones in portrait) */
@media (max-width: 420px) {
  .reader-topbar { gap: 0; padding: env(safe-area-inset-top, 0px) 2px 0 2px; }
  .topbar-btn { min-width: 44px; min-height: 44px; width: 44px; height: 44px; }
  .topbar-sep { display: none; }
  .topbar-title { font-size: 12px; min-width: 0; }
  .page-container { padding: 4px; gap: 8px; }
  .library-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
  .page-slider { width: 60px; }
  #zoom-display { display: none; }
  .status-divider:first-of-type { display: none; }
  .page-slider-wrap { display: none; }
  .doc-card-thumb { height: 140px; }
  .library-title { font-size: 20px; }
  .status-nav-btn { width: 44px; height: 44px; }
  /* Hide read% text to save status bar space */
  #read-pct { display: none; }
  .status-divider:last-of-type { display: none; }
}

/* Very small phones (iPhone SE 1st gen, budget Android) */
@media (max-width: 320px) {
  .topbar-btn { min-width: 34px; min-height: 34px; width: 34px; height: 34px; }
  .topbar-title { display: none; } /* hide title to save space on 320px */
  .reader-statusbar { padding: 0 6px; padding-bottom: env(safe-area-inset-bottom, 0px); }
  .page-jump-display { font-size: 10px; padding: 2px 4px; }
  .status-nav-btn { width: 30px; height: 30px; }
  .lib-btn { padding: 10px 12px; font-size: 12px; }
}

/* Print */
@media print {
  .reader-topbar, .reader-statusbar, .side-panel, .anno-fab, .anno-menu, .anno-bar { display: none !important; }
  .reading-canvas { overflow: visible !important; }
}

/* ===== AUTO-HIDE TOPBAR ===== */
/* transform + opacity are GPU-composited — zero layout cost */
.reader-topbar {
  transition: transform 0.28s cubic-bezier(0.2,0,0,1), opacity 0.28s cubic-bezier(0.2,0,0,1);
  will-change: transform;
}
.reader-topbar.scroll-hidden {
  transform: translateY(-100%);
  opacity: 0;
  pointer-events: none;
  position: absolute;
  top: 0; left: 0; right: 0;
}

/* ===== READING PROGRESS BAR ===== */
.reading-progress-track {
  height: 2px;
  background: transparent;
  flex-shrink: 0;
  overflow: hidden;
  position: sticky;
  top: 0;
  z-index: 50;
  width: 100%;
  align-self: stretch;
}
.reading-progress-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 0 1px 1px 0;
  min-width: 0;
  opacity: 0.7;
}

/* ===== ANNOTATION BAR (bottom toolbar) ===== */
.anno-bar {
  background: var(--bg-primary);
  border-top: 1px solid var(--border);
  box-shadow: 0 -1px 3px rgba(0,0,0,0.03);
  padding: 7px 12px;
  padding-bottom: calc(7px + env(safe-area-inset-bottom, 0px));
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 300;
  flex-shrink: 0;
}
.focus-mode .anno-bar { transform: translateY(100%); opacity: 0; pointer-events: none; }

.anno-bar-tools {
  display: flex;
  align-items: center;
  gap: 2px;
  width: 100%;
  max-width: 480px;
  justify-content: center;
}

.anno-bar-btn {
  width: 42px;
  height: 38px;
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  transition: all var(--transition-fast);
  flex-shrink: 0;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  font-size: 14px;
  font-weight: 800;
  position: relative;
}
.anno-bar-btn:hover { background: var(--bg-secondary); color: var(--text-primary); }
.anno-bar-btn:active { background: var(--bg-tertiary); transform: scale(0.88); }
.anno-bar-btn.active { background: var(--accent-soft); color: var(--accent); }
.anno-bar-btn.active svg { stroke: var(--accent); }

.anno-bar-sep {
  width: 1px;
  height: 22px;
  background: var(--border-strong);
  margin: 0 6px;
  flex-shrink: 0;
}

.anno-bar-colors {
  display: flex;
  gap: 6px;
  align-items: center;
}

.color-swatch {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2.5px solid transparent;
  cursor: pointer;
  transition: transform 0.14s cubic-bezier(0.34,1.56,0.64,1), border-color 0.12s, box-shadow 0.12s;
  flex-shrink: 0;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}
.color-swatch:hover { transform: scale(1.25); }
.color-swatch:active { transform: scale(0.8); }
.color-swatch.active {
  border-color: var(--text-primary);
  box-shadow: 0 0 0 2px var(--bg-canvas);
  transform: scale(1.1);
}

/* ===== SELECTION TOOLBAR (enhanced) ===== */
.sel-tb-actions {
  display: flex;
  align-items: center;
  gap: 2px;
  padding: 4px;
}
.sel-tb-sep {
  width: 1px;
  height: 20px;
  background: var(--border-strong);
  margin: 0 1px;
  flex-shrink: 0;
}
.sel-tb-colors {
  display: flex;
  gap: 6px;
  padding: 5px 10px;
  border-top: 1px solid var(--border);
  justify-content: center;
  align-items: center;
}
.sel-color-btn {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: 2px solid transparent;
  cursor: pointer;
  transition: transform 0.12s cubic-bezier(0.34,1.56,0.64,1), border-color 0.1s;
  flex-shrink: 0;
  -webkit-tap-highlight-color: transparent;
}
.sel-color-btn:hover { transform: scale(1.3); }
.sel-color-btn:active { transform: scale(0.8); }
.sel-color-btn.active { border-color: var(--text-primary); box-shadow: 0 0 0 2px var(--bg-canvas); }

/* ===== LIBRARY STATS ===== */
.lib-stats {
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 12px;
  color: var(--text-tertiary);
  font-weight: 500;
  margin-bottom: 16px;
  padding: 0 2px;
}
.lib-stats-dot { opacity: 0.35; font-size: 14px; line-height: 1; }

/* ===== LIBRARY THUMBNAIL ===== */
.doc-thumb-img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: top center;
  display: block;
  border-radius: 0;
  transition: transform var(--transition-smooth);
}
.doc-card:hover .doc-thumb-img { transform: scale(1.04); }

/* Continue reading badge */
.doc-card-continue {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: var(--accent);
  color: white;
  font-size: 10px;
  font-weight: 700;
  padding: 3px 8px;
  border-radius: var(--radius-full);
  z-index: 3;
  letter-spacing: 0.1px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  pointer-events: none;
}

/* Shimmer skeleton for thumbnail loading */
.thumb-shimmer {
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, var(--bg-secondary) 0%, var(--bg-tertiary) 40%, var(--bg-secondary) 80%);
  background-size: 300% 100%;
  animation: shimmer 1.6s infinite;
}

/* ===== NOTE DIALOG REDESIGN ===== */
.note-dialog-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
  z-index: 9999;
  display: flex;
  align-items: flex-end;
  justify-content: center;
  animation: fadeIn 0.2s ease;
}
@media (min-width: 600px) {
  .note-dialog-overlay { align-items: center; }
}
.note-dialog-sheet {
  background: var(--bg-canvas);
  border-radius: var(--radius-xl) var(--radius-xl) 0 0;
  width: 100%;
  max-width: 520px;
  padding: 0;
  overflow: hidden;
  box-shadow: 0 -8px 40px rgba(0,0,0,0.2);
  animation: slideInBottom 0.3s cubic-bezier(0.2,0,0,1);
}
@media (min-width: 600px) {
  .note-dialog-sheet {
    border-radius: var(--radius-xl);
    animation: scaleIn 0.25s cubic-bezier(0.34,1.56,0.64,1);
  }
}
.note-dialog-handle {
  width: 36px;
  height: 4px;
  background: var(--border-strong);
  border-radius: 2px;
  margin: 12px auto 0;
}
.note-dialog-header {
  padding: 16px 20px 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.note-dialog-title {
  font-size: 16px;
  font-weight: 700;
  letter-spacing: -0.3px;
}
.note-dialog-quote {
  margin: 0 20px 12px;
  padding: 10px 14px;
  background: var(--bg-secondary);
  border-left: 3px solid var(--accent);
  border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
  font-size: 13px;
  color: var(--text-secondary);
  font-style: italic;
  line-height: 1.5;
  max-height: 80px;
  overflow: hidden;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
}
.note-dialog-textarea {
  width: 100%;
  min-height: 120px;
  padding: 12px 20px;
  border: none;
  background: transparent;
  font-family: var(--font-ui);
  font-size: 15px;
  color: var(--text-primary);
  resize: none;
  outline: none;
  line-height: 1.6;
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
}
.note-dialog-textarea::placeholder { color: var(--text-tertiary); }
.note-dialog-footer {
  padding: 12px 20px;
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  align-items: center;
}
.note-dialog-charcount {
  font-size: 12px;
  color: var(--text-tertiary);
  flex: 1;
}
.note-dialog-cancel {
  padding: 9px 18px;
  border-radius: var(--radius-md);
  font-size: 14px;
  font-weight: 500;
  color: var(--text-secondary);
  background: var(--bg-secondary);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-family: var(--font-ui);
}
.note-dialog-cancel:hover { background: var(--bg-tertiary); }
.note-dialog-save {
  padding: 9px 22px;
  border-radius: var(--radius-md);
  font-size: 14px;
  font-weight: 700;
  color: white;
  background: var(--accent);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-family: var(--font-ui);
  box-shadow: 0 2px 8px var(--accent-glow);
  letter-spacing: -0.1px;
}
.note-dialog-save:hover { background: var(--accent-hover); transform: translateY(-1px); }
.note-dialog-save:active { transform: scale(0.96); }

/* ===== RESPONSIVE ANNO BAR ===== */
@media (max-width: 768px) {
  .anno-bar { padding: 6px 8px; padding-bottom: calc(6px + env(safe-area-inset-bottom, 0px)); }
  .anno-bar-btn { width: 38px; height: 38px; }
  .anno-bar-sep { margin: 0 4px; }
  .color-swatch { width: 18px; height: 18px; }
}

/* Mobile two-row anno-bar: tools on top, colors below */
@media (max-width: 600px) {
  .anno-bar {
    padding: 7px 12px;
    padding-bottom: calc(7px + env(safe-area-inset-bottom, 0px));
  }
  .anno-bar-tools {
    flex-wrap: wrap;
    max-width: 100%;
    gap: 0;
    row-gap: 0;
    justify-content: space-around;
  }
  /* Hide the separators — layout handled by two-row design */
  .anno-bar-sep { display: none; }
  /* Colors become their own full-width row below the tools */
  .anno-bar-colors {
    flex: 0 0 100%;
    justify-content: center;
    gap: 12px;
    order: 10;
    padding-top: 7px;
    margin-top: 5px;
    border-top: 1px solid var(--border-strong);
  }
  .color-swatch { width: 22px; height: 22px; }
  /* Undo stays in the tools row (right side) */
  #bar-btn-undo { order: 9; margin-left: auto; }
  .anno-bar-btn { width: 40px; height: 40px; flex-shrink: 0; }
}

@media (max-width: 380px) {
  .anno-bar-tools { justify-content: center; gap: 2px; }
  .anno-bar-btn { width: 36px; height: 36px; }
  #bar-btn-undo { margin-left: 4px; }
}

/* 320px — very small phones */
@media (max-width: 340px) {
  .anno-bar-btn { width: 32px; height: 32px; font-size: 12px; }
  .color-swatch { width: 20px; height: 20px; }
  .anno-bar-colors { gap: 8px; }
}

/* ===== ACCESSIBILITY ===== */
/* Skip-to-content link */
.skip-link {
  position: absolute;
  top: -100%;
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent);
  color: #fff;
  padding: 0.75rem 1.5rem;
  border-radius: var(--radius-md);
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 0.875rem;
  z-index: 10000;
  text-decoration: none;
  transition: top 0.2s;
}
.skip-link:focus {
  top: 1rem;
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

/* Minimum touch targets (WCAG 2.2 AA - 44x44px) */
.reader-topbar button,
.reader-statusbar button,
.anno-bar .anno-bar-btn,
.side-panel-tabs button {
  min-width: 38px;
  min-height: 38px;
}

/* Reduced motion: disable all animations and transitions */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

/* Offline indicator */
.offline-banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: var(--danger);
  color: #fff;
  text-align: center;
  padding: 6px 16px;
  font-family: var(--font-ui);
  font-size: 0.8125rem;
  font-weight: 500;
  z-index: 9999;
  transform: translateY(-100%);
  transition: transform 0.3s;
}
.offline-banner.visible {
  transform: translateY(0);
}
</style>
</head>
<body>
<a href="#root" class="skip-link">Skip to content</a>
<div class="offline-banner" id="offline-banner" role="alert" aria-live="assertive">You are offline. Some features may be unavailable.</div>
<div id="root" role="main"></div>
<script>
// ===== PDF Reader Pro — Full Application =====
// Production-grade PWA with IndexedDB persistence, virtualized scrolling,
// text selection, annotations, freehand drawing, and mobile optimization.

// ===== GLOBAL ERROR HANDLING =====
window.addEventListener('error', (event) => {
  console.error('[PDF Reader Pro]', event.error || event.message);
  const toast = document.querySelector('.toast');
  if (!toast) {
    const t = document.createElement('div');
    t.className = 'toast';
    t.setAttribute('role', 'alert');
    t.setAttribute('aria-live', 'assertive');
    t.textContent = 'Something went wrong. Please try again.';
    document.querySelector('.app-shell')?.appendChild(t);
    setTimeout(() => t.remove(), 3000);
  }
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('[PDF Reader Pro] Unhandled promise rejection:', event.reason);
});

// ===== OFFLINE DETECTION =====
function updateOnlineStatus() {
  const banner = document.getElementById('offline-banner');
  if (banner) {
    banner.classList.toggle('visible', !navigator.onLine);
  }
}
window.addEventListener('online', updateOnlineStatus);
window.addEventListener('offline', updateOnlineStatus);
updateOnlineStatus();

// ===== WEB VITALS MONITORING =====
(function initWebVitals() {
  if (!('PerformanceObserver' in window)) return;

  // Largest Contentful Paint
  try {
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const last = entries[entries.length - 1];
      console.info('[Web Vitals] LCP:', Math.round(last.startTime), 'ms');
    }).observe({ type: 'largest-contentful-paint', buffered: true });
  } catch (_) {}

  // Cumulative Layout Shift
  try {
    let clsScore = 0;
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) clsScore += entry.value;
      }
      console.info('[Web Vitals] CLS:', clsScore.toFixed(4));
    }).observe({ type: 'layout-shift', buffered: true });
  } catch (_) {}

  // Interaction to Next Paint
  try {
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        console.info('[Web Vitals] INP candidate:', Math.round(entry.duration), 'ms');
      }
    }).observe({ type: 'event', buffered: true, durationThreshold: 96 });
  } catch (_) {}
})();

// ===== STORAGE QUOTA UTILITIES =====
async function checkStorageQuota() {
  if (!navigator.storage?.estimate) return { usage: 0, quota: 0, percentUsed: 0 };
  const { usage, quota } = await navigator.storage.estimate();
  return { usage, quota, percentUsed: quota ? (usage / quota) * 100 : 0 };
}

async function warnIfStorageLow() {
  const { percentUsed } = await checkStorageQuota();
  if (percentUsed > 80) {
    showToast('Storage is almost full (' + Math.round(percentUsed) + '%). Consider removing unused PDFs.');
  }
}

const { pdfjsLib } = globalThis;
pdfjsLib.GlobalWorkerOptions.workerSrc = new URL('./lib/pdf.worker.min.js', location.href).href;

// ===== ICONS (inline SVG) =====
const Icons = {
  back: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5"/><path d="m12 19-7-7 7-7"/></svg>`,
  search: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>`,
  bookmark: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z"/></svg>`,
  bookmarkFill: `<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z"/></svg>`,
  sidebar: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M9 3v18"/></svg>`,
  settings: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>`,
  plus: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>`,
  file: `<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>`,
  upload: `<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17,8 12,3 7,8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>`,
  x: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>`,
  highlight: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 11-6 6v3h9l3-3"/><path d="m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L14 4"/></svg>`,
  pen: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg>`,
  note: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8Z"/><path d="M15 3v4a2 2 0 0 0 2 2h4"/></svg>`,
  eraser: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>`,
  undo: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>`,
  redo: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"/></svg>`,
  zoomIn: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></svg>`,
  zoomOut: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="8" x2="14" y1="11" y2="11"/></svg>`,
  focus: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>`,
  moon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>`,
  list: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/></svg>`,
  grid: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="14" y="3" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/><rect width="7" height="7" x="14" y="14" rx="1"/></svg>`,
  trash: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>`,
  copy: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>`,
  download: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>`,
  chevLeft: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>`,
  chevRight: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>`,
  ruler: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z"/><path d="m14.5 12.5 2-2"/><path d="m11.5 9.5 2-2"/><path d="m8.5 6.5 2-2"/><path d="m17.5 15.5 2-2"/></svg>`,
};

// ===== STATE MANAGEMENT =====
const DB_NAME = 'PDFReaderPro';
const DB_VERSION = 2;

class Store {
  constructor() {
    this.state = {
      view: 'library',
      theme: localStorage.getItem('pdfr-theme') || 'light',
      documents: JSON.parse(localStorage.getItem('pdfr-docs') || '[]'),
      currentDoc: null,
      currentPage: 1,
      totalPages: 0,
      zoom: 1,
      fitMode: 'width',
      sidePanel: false,
      sidePanelTab: 'thumbnails',
      searchOpen: false,
      searchQuery: '',
      searchResults: [],
      bookmarks: JSON.parse(localStorage.getItem('pdfr-bookmarks') || '{}'),
      annotations: JSON.parse(localStorage.getItem('pdfr-annotations') || '{}'),
      annotationMode: null,
      annoMenuOpen: false,
      highlightColor: 'yellow',
      focusMode: false,
      showRuler: false,
      rulerY: 300,
      settingsOpen: false,
      showAnnotationBar: true,
      continuousScroll: true,
      toast: null,
      isDragging: false,
      pdfDoc: null,
      outline: [],
      loading: false,
      loadProgress: 0,
      undoStack: [],
    };
    this.listeners = new Set();
    this._prevView = 'library';
  }

  getState() { return this.state; }

  setState(updates) {
    const prev = this.state;
    this.state = { ...this.state, ...updates };
    this.listeners.forEach(fn => fn(this.state, prev));
  }

  subscribe(fn) {
    this.listeners.add(fn);
    return () => this.listeners.delete(fn);
  }

  persistDocs() {
    const docs = this.state.documents.map(d => ({
      id: d.id, name: d.name, pageCount: d.pageCount,
      lastPage: d.lastPage, lastOpened: d.lastOpened, progress: d.progress, size: d.size
    }));
    localStorage.setItem('pdfr-docs', JSON.stringify(docs));
  }

  persistBookmarks() {
    localStorage.setItem('pdfr-bookmarks', JSON.stringify(this.state.bookmarks));
  }

  persistAnnotations() {
    localStorage.setItem('pdfr-annotations', JSON.stringify(this.state.annotations));
  }

  setTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('pdfr-theme', theme);
    this.setState({ theme });
  }
}

const store = new Store();
document.documentElement.setAttribute('data-theme', store.getState().theme);

// ===== INDEXEDDB STORAGE =====
class DocStorage {
  async open() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('files')) {
          db.createObjectStore('files', { keyPath: 'id' });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async saveFile(docId, arrayBuffer) {
    try {
      const db = await this.open();
      const tx = db.transaction('files', 'readwrite');
      tx.objectStore('files').put({ id: docId, data: arrayBuffer });
      return new Promise((resolve, reject) => {
        tx.oncomplete = () => { warnIfStorageLow(); resolve(); };
        tx.onerror = () => reject(tx.error);
      });
    } catch (e) {
      if (e.name === 'QuotaExceededError') {
        showToast('Storage full. Please delete some PDFs to free space.');
      } else {
        console.warn('IndexedDB save failed:', e);
        showToast('Failed to save PDF locally.');
      }
    }
  }

  async getFile(docId) {
    try {
      const db = await this.open();
      const tx = db.transaction('files', 'readonly');
      const req = tx.objectStore('files').get(docId);
      return new Promise((resolve, reject) => {
        req.onsuccess = () => resolve(req.result?.data || null);
        req.onerror = () => reject(req.error);
      });
    } catch (e) {
      console.warn('IndexedDB read failed:', e);
      return null;
    }
  }

  async deleteFile(docId) {
    try {
      const db = await this.open();
      const tx = db.transaction('files', 'readwrite');
      tx.objectStore('files').delete(docId);
    } catch (e) {
      console.warn('IndexedDB delete failed:', e);
    }
  }
}

const docStorage = new DocStorage();

// ===== PDF ENGINE =====
class PDFEngine {
  constructor() {
    this.doc = null;
    this.renderTasks = new Map();
    this.pageTextContents = new Map();
    this.pageDimCache = new Map();
    this.renderScale = window.devicePixelRatio || 1;
    this._lastBuffer = null;
  }

  async loadDocument(file, onProgress) {
    const arrayBuffer = await file.arrayBuffer();
    return this.loadFromBuffer(arrayBuffer, onProgress);
  }

  async loadFromBuffer(arrayBuffer, onProgress) {
    this._lastBuffer = arrayBuffer;
    this.pageDimCache.clear();
    this.pageTextContents.clear();
    this.renderTasks.forEach(t => { try { t.cancel(); } catch(_){} });
    this.renderTasks.clear();

    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
    if (onProgress) {
      loadingTask.onProgress = ({ loaded, total }) => {
        if (total > 0) onProgress(Math.min(99, Math.round((loaded / total) * 100)));
      };
    }
    this.doc = await loadingTask.promise;

    // Cache page 1 dimensions immediately (needed for scale calc)
    const p1 = await this.doc.getPage(1);
    const vp1 = p1.getViewport({ scale: 1 });
    this.pageDimCache.set(1, { width: vp1.width, height: vp1.height });

    // Get outline in background (don't block)
    let outline = [];
    this.doc.getOutline().then(ol => {
      if (ol) this.processOutline(ol).then(o => { outline = o; });
    }).catch(() => {});

    return { doc: this.doc, pageCount: this.doc.numPages, outline, arrayBuffer };
  }

  async processOutline(items, level = 0) {
    const result = [];
    for (const item of items) {
      let pageNum = 1;
      try {
        if (item.dest) {
          const dest = typeof item.dest === 'string'
            ? await this.doc.getDestination(item.dest)
            : item.dest;
          if (dest) {
            const idx = await this.doc.getPageIndex(dest[0]);
            pageNum = idx + 1;
          }
        }
      } catch(_) {}
      const entry = { title: item.title, page: pageNum, level, children: [] };
      if (item.items && item.items.length > 0) {
        entry.children = await this.processOutline(item.items, level + 1);
      }
      result.push(entry);
    }
    return result;
  }

  async renderPage(pageNum, canvas, scale = 1) {
    if (this.renderTasks.has(pageNum)) {
      try { this.renderTasks.get(pageNum).cancel(); } catch(_) {}
    }
    const page = await this.doc.getPage(pageNum);

    // Cache unscaled dims so we never need to getPage again for dimensions
    if (!this.pageDimCache.has(pageNum)) {
      const vp0 = page.getViewport({ scale: 1 });
      this.pageDimCache.set(pageNum, { width: vp0.width, height: vp0.height });
    }

    const viewport = page.getViewport({ scale: scale * this.renderScale });

    canvas.width = viewport.width;
    canvas.height = viewport.height;
    canvas.style.width = (viewport.width / this.renderScale) + 'px';
    canvas.style.height = (viewport.height / this.renderScale) + 'px';

    const ctx = canvas.getContext('2d');
    const renderTask = page.render({ canvasContext: ctx, viewport });
    this.renderTasks.set(pageNum, renderTask);

    try {
      await renderTask.promise;
    } catch (e) {
      if (e.name !== 'RenderingCancelled') throw e;
    }
    this.renderTasks.delete(pageNum);
    return { width: viewport.width / this.renderScale, height: viewport.height / this.renderScale };
  }

  async renderTextLayer(pageNum, container, scale) {
    const existing = container.querySelector('.text-layer');
    if (existing) existing.remove();

    const page = await this.doc.getPage(pageNum);
    // Text layer works in CSS pixels — do NOT multiply by devicePixelRatio
    const viewport = page.getViewport({ scale });
    const textContent = await page.getTextContent();

    const textLayer = document.createElement('div');
    textLayer.className = 'text-layer';
    textLayer.style.width = viewport.width + 'px';
    textLayer.style.height = viewport.height + 'px';

    for (const item of textContent.items) {
      if (!item.str) continue;
      const span = document.createElement('span');
      const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
      const fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
      span.style.left = tx[4] + 'px';
      span.style.top = (tx[5] - fontHeight) + 'px';
      span.style.fontSize = fontHeight + 'px';
      span.textContent = item.str;

      if (item.width > 0) {
        span.style.width = (item.width * scale) + 'px';
      }
      textLayer.appendChild(span);
    }
    container.appendChild(textLayer);
  }

  async renderThumbnail(pageNum, canvas, width = 120) {
    const page = await this.doc.getPage(pageNum);
    const vp = page.getViewport({ scale: 1 });
    const scale = width / vp.width;
    const viewport = page.getViewport({ scale });
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    canvas.style.width = viewport.width + 'px';
    canvas.style.height = viewport.height + 'px';
    const ctx = canvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport }).promise;
  }

  async getPageText(pageNum) {
    if (this.pageTextContents.has(pageNum)) return this.pageTextContents.get(pageNum);
    const page = await this.doc.getPage(pageNum);
    const content = await page.getTextContent();
    const text = content.items.map(item => item.str).join(' ');
    this.pageTextContents.set(pageNum, text);
    return text;
  }

  async searchText(query) {
    if (!query || !this.doc) return [];
    const results = [];
    const lowerQuery = query.toLowerCase();
    for (let i = 1; i <= this.doc.numPages; i++) {
      const text = await this.getPageText(i);
      const lowerText = text.toLowerCase();
      let idx = 0;
      while ((idx = lowerText.indexOf(lowerQuery, idx)) !== -1) {
        const start = Math.max(0, idx - 40);
        const end = Math.min(text.length, idx + query.length + 40);
        let context = text.substring(start, end);
        if (start > 0) context = '...' + context;
        if (end < text.length) context += '...';
        results.push({ page: i, context, matchIndex: idx - start + (start > 0 ? 3 : 0), matchLength: query.length });
        idx += query.length;
      }
    }
    return results;
  }

  async getPageDimensions(pageNum) {
    if (this.pageDimCache.has(pageNum)) return this.pageDimCache.get(pageNum);
    const page = await this.doc.getPage(pageNum);
    const vp = page.getViewport({ scale: 1 });
    const dims = { width: vp.width, height: vp.height };
    this.pageDimCache.set(pageNum, dims);
    return dims;
  }
}

const engine = new PDFEngine();

// ===== UTILITY =====
function generateId() { return Date.now().toString(36) + Math.random().toString(36).substr(2); }

function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / 1048576).toFixed(1) + ' MB';
}

function formatDate(ts) {
  const d = new Date(ts);
  const now = new Date();
  const diff = now - d;
  if (diff < 60000) return 'Just now';
  if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
  if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
  if (diff < 604800000) return Math.floor(diff / 86400000) + 'd ago';
  return d.toLocaleDateString();
}

function showToast(msg) {
  store.setState({ toast: msg });
  setTimeout(() => store.setState({ toast: null }), 2500);
}

// ===== ZOOM CONTROLLER =====
const ZOOM_MIN = 0.3;
const ZOOM_MAX = 4;
const ZOOM_EPSILON = 0.0001;
const ZOOM_STEP_LEVELS = [0.3, 0.4, 0.5, 0.67, 0.8, 0.9, 1, 1.1, 1.25, 1.5, 1.75, 2, 2.5, 3, 3.5, 4];
let zoomRenderTimer = null;
let pendingZoomAnchor = null;
let committedZoomLevel = 1;

function clampZoom(value) {
  return Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, value));
}

function normalizeZoom(value) {
  return Math.round(clampZoom(value) * 1000) / 1000;
}

function setCommittedZoom(value) {
  committedZoomLevel = normalizeZoom(value);
}

function getSteppedZoom(currentZoom, direction) {
  const current = normalizeZoom(currentZoom);
  if (direction > 0) {
    for (const level of ZOOM_STEP_LEVELS) {
      if (level > current + ZOOM_EPSILON) return level;
    }
    return ZOOM_MAX;
  }
  for (let i = ZOOM_STEP_LEVELS.length - 1; i >= 0; i--) {
    const level = ZOOM_STEP_LEVELS[i];
    if (level < current - ZOOM_EPSILON) return level;
  }
  return ZOOM_MIN;
}

function captureZoomAnchor(container, clientX, clientY) {
  if (!container) return null;
  const rect = container.getBoundingClientRect();
  const localX = Number.isFinite(clientX) ? clientX - rect.left : rect.width / 2;
  const localY = Number.isFinite(clientY) ? clientY - rect.top : rect.height / 2;
  const pointX = Math.min(Math.max(localX, 0), rect.width);
  const pointY = Math.min(Math.max(localY, 0), rect.height);
  return {
    xRatio: (container.scrollLeft + pointX) / Math.max(container.scrollWidth, 1),
    yRatio: (container.scrollTop + pointY) / Math.max(container.scrollHeight, 1),
    pointX,
    pointY,
  };
}

function restoreZoomAnchor(container, anchor) {
  if (!container || !anchor) return;
  requestAnimationFrame(() => {
    const maxLeft = Math.max(container.scrollWidth - container.clientWidth, 0);
    const maxTop = Math.max(container.scrollHeight - container.clientHeight, 0);
    container.scrollLeft = Math.min(Math.max(anchor.xRatio * container.scrollWidth - anchor.pointX, 0), maxLeft);
    container.scrollTop = Math.min(Math.max(anchor.yRatio * container.scrollHeight - anchor.pointY, 0), maxTop);
  });
}

function applyZoomPreview(nextZoom, anchor) {
  const pageContainer = document.getElementById('page-container');
  const readingCanvas = document.getElementById('reading-canvas');
  if (!pageContainer || !readingCanvas) return;

  const baseZoom = Math.max(committedZoomLevel, ZOOM_MIN);
  const ratio = Math.min(8, Math.max(0.2, nextZoom / baseZoom));
  pageContainer.classList.add('zoom-preview');
  pageContainer.style.setProperty('--zoom-preview-ratio', ratio.toFixed(4));

  if (anchor) {
    const anchorXPct = (anchor.pointX / Math.max(readingCanvas.clientWidth, 1)) * 100;
    const anchorYPct = (anchor.pointY / Math.max(readingCanvas.clientHeight, 1)) * 100;
    pageContainer.style.setProperty('--zoom-anchor-x', anchorXPct.toFixed(2) + '%');
    pageContainer.style.setProperty('--zoom-anchor-y', anchorYPct.toFixed(2) + '%');
  }
}

function clearZoomPreview() {
  const pageContainer = document.getElementById('page-container');
  if (!pageContainer) return;
  pageContainer.classList.remove('zoom-preview');
  pageContainer.style.removeProperty('--zoom-preview-ratio');
  pageContainer.style.removeProperty('--zoom-anchor-x');
  pageContainer.style.removeProperty('--zoom-anchor-y');
}

function syncZoomIndicators(zoom = store.getState().zoom) {
  const label = Math.round(zoom * 100) + '%';
  const zoomDisplay = document.getElementById('zoom-display');
  if (zoomDisplay) zoomDisplay.textContent = label;
  const zoomInfo = document.getElementById('zoom-info');
  if (zoomInfo) zoomInfo.textContent = label;

  const zoomOutBtn = document.getElementById('btn-zoom-out');
  const zoomInBtn = document.getElementById('btn-zoom-in');
  const atMin = zoom <= ZOOM_MIN + ZOOM_EPSILON;
  const atMax = zoom >= ZOOM_MAX - ZOOM_EPSILON;
  if (zoomOutBtn) zoomOutBtn.disabled = atMin;
  if (zoomInBtn) zoomInBtn.disabled = atMax;
}

function scheduleZoomRender(delayMs = 0, forceRebuild = false) {
  clearTimeout(zoomRenderTimer);
  zoomRenderTimer = setTimeout(async () => {
    const state = store.getState();
    if (state.view !== 'reader' || !state.pdfDoc || state.loading) {
      pendingZoomAnchor = null;
      clearZoomPreview();
      return;
    }
    const anchor = pendingZoomAnchor;
    pendingZoomAnchor = null;
    clearZoomPreview();
    await renderVisiblePages(forceRebuild);
    setCommittedZoom(store.getState().zoom);
    restoreZoomAnchor(document.getElementById('reading-canvas'), anchor);
  }, delayMs);
}

function setZoomLevel(targetZoom, options = {}) {
  const { renderMode = 'immediate', anchorClientX = null, anchorClientY = null, forceRebuild = false } = options;
  const state = store.getState();
  const nextZoom = normalizeZoom(targetZoom);

  if (Math.abs(nextZoom - state.zoom) <= ZOOM_EPSILON) {
    syncZoomIndicators(nextZoom);
    return false;
  }

  const anchor = captureZoomAnchor(document.getElementById('reading-canvas'), anchorClientX, anchorClientY);
  pendingZoomAnchor = anchor;
  if (renderMode === 'debounced') applyZoomPreview(nextZoom, anchor);
  else clearZoomPreview();
  store.setState({ zoom: nextZoom, fitMode: 'width' });
  syncZoomIndicators(nextZoom);

  if (renderMode === 'debounced') {
    scheduleZoomRender(140, forceRebuild);
  } else if (renderMode !== 'none') {
    scheduleZoomRender(0, forceRebuild);
  }
  return true;
}

function nudgeZoom(direction, options = {}) {
  const current = store.getState().zoom;
  const target = getSteppedZoom(current, direction);
  return setZoomLevel(target, options);
}

function showNoteDialog(selectedText, onSave) {
  const hasQuote = selectedText && selectedText.trim().length > 0;

  const overlay = document.createElement('div');
  overlay.className = 'note-dialog-overlay';
  overlay.setAttribute('role', 'dialog');
  overlay.setAttribute('aria-modal', 'true');
  overlay.setAttribute('aria-label', hasQuote ? 'Add note' : 'Quick note');

  overlay.innerHTML = `
    <div class="note-dialog-sheet">
      <div class="note-dialog-handle"></div>
      <div class="note-dialog-header">
        <div class="note-dialog-title">${hasQuote ? 'Add Note' : 'Quick Note'}</div>
        <button class="topbar-btn" id="note-close-btn" aria-label="Close" style="width:32px;height:32px">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
        </button>
      </div>
      ${hasQuote ? `<div class="note-dialog-quote">"${escapeHtml(selectedText.slice(0, 200))}${selectedText.length > 200 ? '…' : ''}"</div>` : ''}
      <textarea class="note-dialog-textarea" id="note-input" placeholder="Write your note here…" rows="4" autofocus></textarea>
      <div class="note-dialog-footer">
        <span class="note-dialog-charcount" id="note-charcount">0 chars</span>
        <button class="note-dialog-cancel" id="note-cancel">Cancel</button>
        <button class="note-dialog-save" id="note-save">Save Note</button>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);
  const input = overlay.querySelector('#note-input');
  const charcount = overlay.querySelector('#note-charcount');

  setTimeout(() => input.focus(), 80);

  input.addEventListener('input', () => {
    const len = input.value.length;
    charcount.textContent = len + (len === 1 ? ' char' : ' chars');
  });

  function doSave() {
    const text = input.value.trim();
    if (text) onSave(text);
    overlay.remove();
  }

  overlay.querySelector('#note-cancel').onclick = () => overlay.remove();
  overlay.querySelector('#note-close-btn').onclick = () => overlay.remove();
  overlay.querySelector('#note-save').onclick = doSave;

  input.addEventListener('keydown', (e) => {
    if ((e.key === 'Enter' && (e.ctrlKey || e.metaKey)) || (e.key === 'Enter' && !e.shiftKey && window.innerWidth > 600)) {
      e.preventDefault();
      doSave();
    }
    if (e.key === 'Escape') overlay.remove();
  });

  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) overlay.remove();
  });
}

function escapeHtml(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// ===== FILE HANDLING =====
async function handleFileOpen(file) {
  if (!file || file.type !== 'application/pdf') {
    showToast('Please select a valid PDF file');
    return;
  }
  store.setState({ loading: true, loadProgress: 0, view: 'reader' });

  try {
    // Read file buffer and make a copy for IndexedDB before pdf.js detaches the original
    const arrayBuffer = await file.arrayBuffer();
    const bufferForDB = arrayBuffer.slice(0);

    const { doc, pageCount, outline } = await engine.loadFromBuffer(arrayBuffer, (pct) => {
      store.setState({ loadProgress: pct });
    });

    const docId = generateId();
    const docInfo = {
      id: docId,
      name: file.name.replace(/\.pdf$/i, ''),
      pageCount,
      lastPage: 1,
      lastOpened: Date.now(),
      progress: 0,
      size: file.size,
    };

    // Check if doc already exists
    const existing = store.getState().documents.find(d => d.name === docInfo.name && d.size === file.size);
    if (existing) {
      docInfo.id = existing.id;
      docInfo.lastPage = existing.lastPage || 1;
      docInfo.progress = existing.progress || 0;
      const docs = store.getState().documents.map(d => d.id === existing.id ? { ...d, ...docInfo } : d);
      store.setState({ documents: docs });
    } else {
      store.setState({ documents: [...store.getState().documents, docInfo] });
    }

    // Persist PDF data to IndexedDB (using the pre-detachment copy)
    docStorage.saveFile(docInfo.id, bufferForDB).catch(() => {});

    store.setState({
      currentDoc: docInfo,
      pdfDoc: doc,
      totalPages: pageCount,
      currentPage: docInfo.lastPage,
      outline,
      loading: false,
      loadProgress: 0,
      zoom: 1,
      fitMode: 'width',
      undoStack: [],
    });
    store.persistDocs();

    requestAnimationFrame(() => window.dispatchEvent(new Event('pdf-loaded')));
    // Capture thumbnail in background (non-blocking)
    setTimeout(() => captureLibraryThumb(docInfo.id, doc), 800);
  } catch (err) {
    console.error('Failed to load PDF:', err);
    store.setState({ loading: false, loadProgress: 0, view: 'library' });
    if (err.name === 'PasswordException') {
      showToast('This PDF is password-protected.');
    } else {
      showToast('Failed to load PDF. The file may be corrupted.');
    }
  }
}

async function handleOpenFromLibrary(docId) {
  const doc = store.getState().documents.find(d => d.id === docId);
  if (!doc) return;

  store.setState({ loading: true, loadProgress: 0, view: 'reader' });

  try {
    const buffer = await docStorage.getFile(docId);
    if (buffer) {
      const { doc: pdfDoc, pageCount, outline } = await engine.loadFromBuffer(buffer, (pct) => {
        store.setState({ loadProgress: pct });
      });
      store.setState({
        currentDoc: { ...doc, lastOpened: Date.now() },
        pdfDoc,
        totalPages: pageCount,
        currentPage: doc.lastPage || 1,
        outline,
        loading: false,
        zoom: 1,
        fitMode: 'width',
        undoStack: [],
      });
      const docs = store.getState().documents.map(d => d.id === docId ? { ...d, lastOpened: Date.now() } : d);
      store.setState({ documents: docs });
      store.persistDocs();
      requestAnimationFrame(() => window.dispatchEvent(new Event('pdf-loaded')));
      // Capture thumbnail if not yet stored
      setTimeout(() => captureLibraryThumb(docId, pdfDoc), 800);
    } else {
      store.setState({ loading: false, view: 'library' });
      showToast('File not found. Please re-open the PDF.');
      promptFileOpen();
    }
  } catch (err) {
    console.error('Failed to open from library:', err);
    store.setState({ loading: false, view: 'library' });
    showToast('Failed to open document.');
  }
}

async function deleteDocument(docId) {
  await docStorage.deleteFile(docId);
  try { localStorage.removeItem('pdfr-thumb-' + docId); } catch(_) {}
  const docs = store.getState().documents.filter(d => d.id !== docId);
  const bookmarks = { ...store.getState().bookmarks };
  delete bookmarks[docId];
  const annotations = { ...store.getState().annotations };
  delete annotations[docId];
  store.setState({ documents: docs, bookmarks, annotations });
  store.persistDocs();
  store.persistBookmarks();
  store.persistAnnotations();
  showToast('Document removed');
}

function promptFileOpen() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.pdf';
  input.onchange = (e) => { if (e.target.files[0]) handleFileOpen(e.target.files[0]); };
  input.click();
}

// ===== RENDER FUNCTIONS =====
let currentView = null;

function renderApp() {
  const state = store.getState();
  const root = document.getElementById('root');
  currentView = state.view;
  clearTimeout(zoomRenderTimer);
  pendingZoomAnchor = null;
  clearZoomPreview();

  if (state.view === 'library') {
    root.innerHTML = renderLibrary(state);
    attachLibraryEvents();
  } else {
    root.innerHTML = renderReader(state);
    attachReaderEvents();
  }
}

// ===== LIBRARY VIEW =====
function renderLibrary(state) {
  const docs = state.documents.sort((a, b) => (b.lastOpened || 0) - (a.lastOpened || 0));
  const totalAnnos = Object.values(state.annotations || {}).reduce((s, a) => s + a.length, 0);
  const totalBms = Object.values(state.bookmarks || {}).reduce((s, a) => s + a.length, 0);

  return `
    <div class="app-shell" data-view="library">
      ${state.isDragging ? `
        <div class="drop-zone-overlay">
          <div class="drop-zone-box">
            ${Icons.upload}
            <h3>Drop PDF Here</h3>
            <p>Release to open your document</p>
          </div>
        </div>
      ` : ''}

      <div class="library">
        <div class="library-header">
          <div class="library-brand">
            <div class="library-logo">P</div>
            <div>
              <div class="library-title">PDF Reader Pro</div>
              <div class="library-subtitle">Your reading workspace</div>
            </div>
          </div>

          <div class="library-actions">
            <button class="lib-btn lib-btn-primary" id="btn-open-file" aria-label="Open PDF file">
              ${Icons.plus} Open PDF
            </button>
            <button class="lib-btn lib-btn-secondary" id="btn-settings-lib" aria-label="Settings">
              ${Icons.settings}
            </button>
          </div>

          ${docs.length > 0 ? `
            <div class="library-search">
              ${Icons.search}
              <input type="text" placeholder="Search your library..." id="lib-search-input" aria-label="Search library">
            </div>

            <div class="lib-stats">
              <span>${docs.length} ${docs.length === 1 ? 'document' : 'documents'}</span>
              ${totalAnnos > 0 ? `<span class="lib-stats-dot">·</span><span>${totalAnnos} annotation${totalAnnos !== 1 ? 's' : ''}</span>` : ''}
              ${totalBms > 0 ? `<span class="lib-stats-dot">·</span><span>${totalBms} bookmark${totalBms !== 1 ? 's' : ''}</span>` : ''}
            </div>
          ` : ''}
        </div>

        <div class="library-content">
          ${docs.length === 0 ? `
            <div class="library-empty">
              <div class="library-empty-icon">
                <svg width="52" height="52" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                  <polyline points="14,2 14,8 20,8"/>
                  <line x1="8" y1="13" x2="16" y2="13"/>
                  <line x1="8" y1="17" x2="13" y2="17"/>
                </svg>
              </div>
              <h3>No PDFs yet</h3>
              <p>Tap "Open PDF" to add your first document, or drag and drop a file anywhere.</p>
              <button class="lib-btn lib-btn-primary" id="btn-open-empty" style="margin-top:16px;max-width:200px">
                ${Icons.plus} Open PDF
              </button>
            </div>
          ` : `
            <div class="library-grid" id="library-grid">
              ${docs.map((doc, i) => {
                const thumb = getThumb(doc.id);
                const hasProgress = doc.progress > 0;
                const isContinue = doc.lastPage > 1;
                return `
                <div class="doc-card" data-doc-id="${escapeHtml(doc.id)}" style="animation-delay: ${Math.min(i * 0.04, 0.3)}s">
                  <div class="doc-card-thumb">
                    <button class="doc-card-delete" data-delete-id="${escapeHtml(doc.id)}" aria-label="Remove document">${Icons.trash}</button>
                    ${thumb
                      ? `<img class="doc-thumb-img" src="${thumb}" alt="Page preview" loading="lazy">`
                      : `<div class="thumb-placeholder">
                          ${Icons.file}
                          <span style="font-size:11px;font-weight:500">${doc.pageCount || '?'} pages</span>
                        </div>`
                    }
                    ${isContinue ? `<div class="doc-card-continue">p.${doc.lastPage}</div>` : ''}
                    ${hasProgress ? `
                      <div class="doc-card-progress">
                        <div class="doc-card-progress-bar" style="width:${Math.round(doc.progress * 100)}%"></div>
                      </div>
                    ` : ''}
                  </div>
                  <div class="doc-card-info">
                    <div class="doc-card-title">${escapeHtml(doc.name)}</div>
                    <div class="doc-card-meta">
                      <span>${formatFileSize(doc.size || 0)}</span>
                      <span>&middot;</span>
                      <span>${formatDate(doc.lastOpened)}</span>
                    </div>
                  </div>
                </div>`;
              }).join('')}
            </div>
          `}
        </div>
      </div>

      ${state.settingsOpen ? renderSettingsModal(state) : ''}
      ${state.toast ? `<div class="toast" role="status" aria-live="polite">${escapeHtml(state.toast)}</div>` : ''}
    </div>
  `;
}

// ===== READER VIEW =====
function renderReader(state) {
  const isBookmarked = state.bookmarks[state.currentDoc?.id]?.includes(state.currentPage);
  const atMinZoom = state.zoom <= ZOOM_MIN + ZOOM_EPSILON;
  const atMaxZoom = state.zoom >= ZOOM_MAX - ZOOM_EPSILON;

  return `
    <div class="app-shell ${state.focusMode ? 'focus-mode' : ''}" data-view="reader">
      <div class="reader-shell">
        ${state.loading ? `<div class="load-progress"><div class="load-progress-bar" style="width:${state.loadProgress || 5}%"></div></div>` : ''}
        <div class="reader-topbar ${state.focusMode ? 'hidden' : ''}">
          <button class="topbar-btn" id="btn-back" title="Back to Library" aria-label="Back to Library">${Icons.back}</button>
          <button class="topbar-btn ${state.sidePanel ? 'active' : ''}" id="btn-sidebar" title="Toggle Sidebar" aria-label="Toggle Sidebar">${Icons.sidebar}</button>
          <div class="topbar-sep"></div>
          <div class="topbar-title">${escapeHtml(state.currentDoc?.name || 'Document')}</div>
          <div class="topbar-sep"></div>
          <button class="topbar-btn" id="btn-zoom-out" title="Zoom Out" aria-label="Zoom Out" ${atMinZoom ? 'disabled' : ''}>${Icons.zoomOut}</button>
          <span id="zoom-display" style="font-size:12px;font-weight:600;color:var(--text-tertiary);min-width:40px;text-align:center;font-variant-numeric:tabular-nums">${Math.round(state.zoom * 100)}%</span>
          <button class="topbar-btn" id="btn-zoom-in" title="Zoom In" aria-label="Zoom In" ${atMaxZoom ? 'disabled' : ''}>${Icons.zoomIn}</button>
          <div class="topbar-sep"></div>
          <button class="topbar-btn" id="btn-search" title="Search (Ctrl+F)" aria-label="Search">${Icons.search}</button>
          <button class="topbar-btn" id="btn-download" title="Download PDF" aria-label="Download PDF">${Icons.download}</button>
          <button class="topbar-btn" id="btn-bookmark" title="Bookmark (Ctrl+B)" aria-label="Bookmark">${isBookmarked ? Icons.bookmarkFill : Icons.bookmark}</button>
          <button class="topbar-btn" id="btn-focus" title="Focus Mode" aria-label="Focus Mode">${Icons.focus}</button>
          <button class="topbar-btn" id="btn-settings" title="Settings" aria-label="Settings">${Icons.settings}</button>
        </div>

        <div class="reader-body">
          ${state.sidePanel ? renderSidePanel(state) : ''}
          <div class="reading-canvas" id="reading-canvas" role="main">
            ${state.loading ? `
              <div class="loading-wrap">
                <div class="spinner"></div>
                <span>Loading document...</span>
              </div>
            ` : `
              <div class="reading-progress-track" id="reading-progress-track" aria-hidden="true">
                <div class="reading-progress-fill" id="reading-progress-fill"
                     style="width:${Math.round((state.currentPage / Math.max(state.totalPages,1)) * 100)}%"></div>
              </div>
              <div class="page-container" id="page-container"></div>
            `}
          </div>
        </div>

        <div class="reader-statusbar ${state.focusMode ? 'hidden' : ''}">
          <div class="status-left">
            <button class="status-nav-btn" id="btn-prev-page" aria-label="Previous page" title="Previous page" ${state.currentPage <= 1 ? 'disabled' : ''}>${Icons.chevLeft}</button>
            <div class="page-jump-display" id="page-jump-display" title="Click to jump to page">
              <span id="page-num-current">${state.currentPage}</span>
              <span style="opacity:0.4">/</span>
              <span>${state.totalPages}</span>
            </div>
            <button class="status-nav-btn" id="btn-next-page" aria-label="Next page" title="Next page" ${state.currentPage >= state.totalPages ? 'disabled' : ''}>${Icons.chevRight}</button>
            <div class="status-divider"></div>
            <div class="page-slider-wrap">
              <input type="range" class="page-slider" id="page-slider"
                min="1" max="${state.totalPages}" value="${state.currentPage}" aria-label="Page slider">
            </div>
          </div>
          <div class="status-right">
            <span id="zoom-info">${Math.round(state.zoom * 100)}%</span>
            <div class="status-divider"></div>
            <span id="read-pct">${Math.round((state.currentPage / Math.max(state.totalPages, 1)) * 100)}% read</span>
          </div>
        </div>

        ${state.searchOpen ? renderSearchOverlay(state) : ''}
        ${!state.focusMode && !state.loading ? renderAnnotationToolbar(state) : ''}
      </div>

      ${state.showRuler ? `<div class="reading-ruler" style="top:${state.rulerY}px"></div>` : ''}
      ${state.settingsOpen ? renderSettingsModal(state) : ''}
      ${state.toast ? `<div class="toast" role="status" aria-live="polite">${escapeHtml(state.toast)}</div>` : ''}
    </div>
  `;
}

function renderSidePanel(state) {
  const isMobile = window.innerWidth <= 768;
  return `
    ${isMobile ? '<div class="sidebar-backdrop" id="sidebar-backdrop"></div>' : ''}
    <div class="side-panel" role="navigation">
      <div class="side-panel-tabs">
        <button class="sp-tab ${state.sidePanelTab === 'thumbnails' ? 'active' : ''}" data-sptab="thumbnails">Pages</button>
        <button class="sp-tab ${state.sidePanelTab === 'outline' ? 'active' : ''}" data-sptab="outline">Outline</button>
        <button class="sp-tab ${state.sidePanelTab === 'bookmarks' ? 'active' : ''}" data-sptab="bookmarks">Bookmarks</button>
        <button class="sp-tab ${state.sidePanelTab === 'annotations' ? 'active' : ''}" data-sptab="annotations">Notes</button>
      </div>
      <div class="side-panel-content" id="sp-content">
        ${renderSidePanelContent(state)}
      </div>
    </div>
  `;
}

function renderSidePanelContent(state) {
  switch (state.sidePanelTab) {
    case 'thumbnails':
      return `<div class="thumb-grid" id="thumb-grid">
        ${Array.from({ length: state.totalPages }, (_, i) => `
          <div class="thumb-item ${state.currentPage === i + 1 ? 'active' : ''}" data-page="${i + 1}">
            <canvas id="thumb-canvas-${i + 1}"></canvas>
            <span class="thumb-label">Page ${i + 1}</span>
          </div>
        `).join('')}
      </div>`;
    case 'outline':
      if (!state.outline || state.outline.length === 0) {
        return `<div style="padding:20px;text-align:center;color:var(--text-tertiary);font-size:13px">No outline available for this document</div>`;
      }
      return renderOutlineItems(state.outline);
    case 'bookmarks':
      const docBookmarks = state.bookmarks[state.currentDoc?.id] || [];
      if (docBookmarks.length === 0) {
        return `<div style="padding:20px;text-align:center;color:var(--text-tertiary);font-size:13px">No bookmarks yet. Click the bookmark icon to add one.</div>`;
      }
      return docBookmarks.map(p => `
        <div class="bookmark-item" data-page="${p}">
          <div class="bookmark-dot"></div>
          <div class="bookmark-info">
            <div class="bookmark-page">Page ${p}</div>
            <div class="bookmark-label">Bookmarked</div>
          </div>
          <button class="bookmark-remove topbar-btn" data-remove-bm="${p}" style="width:28px;height:28px" aria-label="Remove bookmark">${Icons.trash}</button>
        </div>
      `).join('');
    case 'annotations':
      const docAnnos = state.annotations[state.currentDoc?.id] || [];
      if (docAnnos.length === 0) {
        return `<div style="padding:20px;text-align:center;color:var(--text-tertiary);font-size:13px">No annotations yet. Select the note tool and tap anywhere on a page to add a note, or select text to highlight.</div>`;
      }
      return docAnnos.sort((a, b) => a.page - b.page).map(a => {
        const label = a.type === 'note' && a.content ? a.content : (a.text || 'Highlight');
        const typeLabel = a.type === 'note' && !a.rects ? 'pin note' : a.type;
        return `
        <div class="annotation-item" data-page="${a.page}"
             style="border-left-color: var(--highlight-${a.color || 'yellow'})">
          <div class="annotation-text">${escapeHtml(label)}</div>
          <div class="annotation-meta">Page ${a.page} &middot; ${typeLabel} &middot; ${formatDate(a.created)}</div>
        </div>`;
      }).join('');
    default:
      return '';
  }
}

function renderOutlineItems(items) {
  return items.map(item => `
    <div class="outline-item outline-item-l${Math.min(item.level + 1, 3)}" data-page="${item.page}">
      ${escapeHtml(item.title)}
    </div>
    ${item.children ? renderOutlineItems(item.children) : ''}
  `).join('');
}

function renderSearchOverlay(state) {
  return `
    <div class="search-overlay" id="search-overlay">
      <div class="search-input-wrap">
        ${Icons.search}
        <input type="text" placeholder="Search in document..." id="search-input"
               value="${escapeHtml(state.searchQuery)}" autofocus aria-label="Search in document">
        <button class="topbar-btn" id="btn-close-search" style="width:28px;height:28px" aria-label="Close search">${Icons.x}</button>
      </div>
      <div class="search-results" id="search-results">
        ${state.searchResults.length === 0 && state.searchQuery ?
          `<div style="padding:20px;text-align:center;color:var(--text-tertiary);font-size:13px">No results found</div>` :
          state.searchResults.map((r, i) => {
            const before = escapeHtml(r.context.substring(0, r.matchIndex));
            const match = escapeHtml(r.context.substring(r.matchIndex, r.matchIndex + r.matchLength));
            const after = escapeHtml(r.context.substring(r.matchIndex + r.matchLength));
            return `
              <div class="search-result-item" data-page="${r.page}" data-idx="${i}">
                <div class="search-result-page">Page ${r.page}</div>
                <div class="search-result-context">${before}<mark>${match}</mark>${after}</div>
              </div>
            `;
          }).join('')
        }
      </div>
      ${state.searchResults.length > 0 ?
        `<div class="search-count">${state.searchResults.length} result${state.searchResults.length !== 1 ? 's' : ''} found</div>` : ''}
    </div>
  `;
}

function renderAnnotationToolbar(state) {
  const mode = state.annotationMode;
  const color = state.highlightColor;
  const colors = [
    { key: 'yellow', bg: 'rgba(250,204,21,0.95)' },
    { key: 'green',  bg: 'rgba(74,222,128,0.95)' },
    { key: 'blue',   bg: 'rgba(96,165,250,0.95)' },
    { key: 'pink',   bg: 'rgba(244,114,182,0.95)' },
    { key: 'purple', bg: 'rgba(168,85,247,0.95)' },
  ];
  return `
    <div class="anno-bar" id="anno-bar" role="toolbar" aria-label="Annotation tools">
      <div class="anno-bar-tools">
        <button class="anno-bar-btn ${mode === 'highlight' ? 'active' : ''}" id="bar-btn-highlight"
                title="Highlight (H)" aria-label="Highlight" aria-pressed="${mode === 'highlight'}">
          ${Icons.highlight}
        </button>
        <button class="anno-bar-btn ${mode === 'underline' ? 'active' : ''}" id="bar-btn-underline"
                title="Underline (U)" aria-label="Underline" aria-pressed="${mode === 'underline'}"
                style="font-size:15px;text-decoration:underline;text-underline-offset:2px;">U</button>
        <button class="anno-bar-btn ${mode === 'strikethrough' ? 'active' : ''}" id="bar-btn-strikethrough"
                title="Strikethrough (S)" aria-label="Strikethrough" aria-pressed="${mode === 'strikethrough'}"
                style="font-size:15px;text-decoration:line-through;">S</button>
        <button class="anno-bar-btn ${mode === 'note' ? 'active' : ''}" id="bar-btn-note"
                title="Note (N)" aria-label="Note" aria-pressed="${mode === 'note'}">
          ${Icons.note}
        </button>
        <button class="anno-bar-btn ${mode === 'pen' ? 'active' : ''}" id="bar-btn-pen"
                title="Draw (D)" aria-label="Draw" aria-pressed="${mode === 'pen'}">
          ${Icons.pen}
        </button>
        <button class="anno-bar-btn ${mode === 'eraser' ? 'active' : ''}" id="bar-btn-eraser"
                title="Eraser (E)" aria-label="Eraser" aria-pressed="${mode === 'eraser'}">
          ${Icons.eraser}
        </button>
        <div class="anno-bar-sep"></div>
        <div class="anno-bar-colors" role="group" aria-label="Highlight color">
          ${colors.map(c => `<button class="color-swatch ${color === c.key ? 'active' : ''}"
              data-color="${c.key}" title="${c.key}" aria-label="${c.key} color" aria-pressed="${color === c.key}"
              style="background:${c.bg}"></button>`).join('')}
        </div>
        <div class="anno-bar-sep"></div>
        <button class="anno-bar-btn" id="bar-btn-undo" title="Undo last annotation (Ctrl+Z)" aria-label="Undo">
          ${Icons.undo}
        </button>
      </div>
    </div>
  `;
}

function renderSettingsModal(state) {
  return `
    <div class="modal-overlay" id="modal-overlay">
      <div class="modal-content" role="dialog" aria-label="Settings">
        <div class="modal-header">
          <h2>Settings</h2>
          <button class="topbar-btn" id="btn-close-settings" aria-label="Close settings">${Icons.x}</button>
        </div>
        <div class="modal-body">
          <div class="setting-group">
            <div class="setting-group-title">Appearance</div>
            <div class="setting-row">
              <div>
                <div class="setting-label">Theme</div>
                <div class="setting-desc">Choose your reading theme</div>
              </div>
            </div>
            <div class="theme-picker" style="margin-top:8px">
              <button class="theme-option theme-light ${state.theme === 'light' ? 'active' : ''}" data-theme="light">Light</button>
              <button class="theme-option theme-dark ${state.theme === 'dark' ? 'active' : ''}" data-theme="dark">Dark</button>
              <button class="theme-option theme-sepia ${state.theme === 'sepia' ? 'active' : ''}" data-theme="sepia">Sepia</button>
            </div>
          </div>
          <div class="setting-group">
            <div class="setting-group-title">Reading</div>
            <div class="setting-row">
              <div class="setting-label">Continuous Scroll</div>
              <div class="toggle ${state.continuousScroll ? 'active' : ''}" id="toggle-scroll" role="switch" aria-checked="${state.continuousScroll}"></div>
            </div>
            <div class="setting-row">
              <div class="setting-label">Reading Ruler</div>
              <div class="toggle ${state.showRuler ? 'active' : ''}" id="toggle-ruler" role="switch" aria-checked="${state.showRuler}"></div>
            </div>
            <div class="setting-row" style="align-items:flex-start;flex-direction:column;gap:8px">
              <div class="setting-label">Zoom Level</div>
              <div class="zoom-presets">
                ${[{v:'fit',l:'Fit Width'},{v:'0.5',l:'50%'},{v:'0.75',l:'75%'},{v:'1',l:'100%'},{v:'1.25',l:'125%'},{v:'1.5',l:'150%'},{v:'2',l:'200%'},{v:'3',l:'300%'}].map(z => {
                  const isActive = z.v === 'fit'
                    ? state.fitMode === 'width' && Math.abs(state.zoom - 1) < 0.01
                    : Math.abs(state.zoom - parseFloat(z.v)) < 0.01;
                  return `<button class="zoom-preset-btn ${isActive ? 'active' : ''}" data-zoom-preset="${z.v}">${z.l}</button>`;
                }).join('')}
              </div>
            </div>
          </div>
          <div class="setting-group">
            <div class="setting-group-title">About</div>
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
              <div style="width:40px;height:40px;background:linear-gradient(135deg,#3b82f6,#8b5cf6);border-radius:10px;display:flex;align-items:center;justify-content:center;color:white;font-weight:800;font-size:18px;flex-shrink:0">P</div>
              <div>
                <div style="font-weight:700;font-size:15px;letter-spacing:-0.2px">PDF Reader Pro</div>
                <div style="font-size:12px;color:var(--text-tertiary)">Version 2.0</div>
              </div>
            </div>
            <div style="font-size:13px;color:var(--text-secondary);line-height:1.6">
              A premium PDF reading experience with annotations, bookmarks, and text search. Built with pdf.js.
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
}

// ===== VIRTUALIZED PAGE RENDERING =====
let pagePositions = [];
let renderedPages = new Set();
let effectiveScale = 1;
let _renderingPages = false;
let _hasPendingRender = false;
let _pendingRenderForce = false;
let _builtScale = null;
let _builtMode = null;
let _builtPageCount = 0;

function computePageLayout() {
  const state = store.getState();
  if (!state.pdfDoc) return;

  const canvas = document.getElementById('reading-canvas');
  if (!canvas) return;
  // Account for page-container padding (smaller on mobile)
  const pc = document.getElementById('page-container');
  const padding = pc ? parseFloat(getComputedStyle(pc).paddingLeft) * 2 : 40;
  const canvasWidth = canvas.clientWidth - padding;
  if (canvasWidth <= 0) return;

  const dims1 = engine.pageDimCache.get(1) || { width: 612, height: 792 };
  const fitWidthScale = canvasWidth / dims1.width;
  effectiveScale = state.fitMode === 'width' ? fitWidthScale * state.zoom : state.zoom;

  // Wrapper sizes must be in CSS pixels (NOT divided by dpr).
  // renderPage sets canvas CSS size = dims * effectiveScale, so wrappers must match.
  const defaultH = dims1.height * effectiveScale;
  const defaultW = dims1.width * effectiveScale;

  pagePositions = [];
  let yOffset = 20;
  for (let i = 1; i <= state.totalPages; i++) {
    const cached = engine.pageDimCache.get(i);
    const h = cached ? cached.height * effectiveScale : defaultH;
    const w = cached ? cached.width * effectiveScale : defaultW;
    pagePositions.push({ page: i, top: yOffset, height: h, width: w });
    yOffset += h + 28;
  }
}

function buildPagePlaceholders(force) {
  const container = document.getElementById('page-container');
  if (!container) return;

  const state = store.getState();
  const scaleKey = Math.round(effectiveScale * 1000);
  const modeKey = state.continuousScroll;
  const countKey = state.totalPages;

  // Skip rebuild if layout hasn't changed (prevents destroying rendered canvases)
  if (!force && scaleKey === _builtScale && modeKey === _builtMode && countKey === _builtPageCount && container.children.length > 0) {
    return;
  }

  _builtScale = scaleKey;
  _builtMode = modeKey;
  _builtPageCount = countKey;

  // Cancel any in-flight render tasks before clearing
  engine.renderTasks.forEach(t => { try { t.cancel(); } catch(_){} });
  engine.renderTasks.clear();

  container.innerHTML = '';
  renderedPages.clear();

  const frag = document.createDocumentFragment();

  if (state.continuousScroll) {
    for (const pos of pagePositions) {
      const wrapper = document.createElement('div');
      wrapper.className = 'page-wrapper';
      wrapper.id = `page-wrap-${pos.page}`;
      wrapper.dataset.page = pos.page;
      wrapper.style.cssText = `width:${pos.width}px;height:${pos.height}px;position:relative`;

      const placeholder = document.createElement('div');
      placeholder.className = 'page-placeholder';
      placeholder.style.cssText = 'width:100%;height:100%';
      placeholder.textContent = pos.page;
      wrapper.appendChild(placeholder);

      const label = document.createElement('div');
      label.className = 'page-number-label';
      label.textContent = pos.page;

      frag.appendChild(wrapper);
      frag.appendChild(label);
    }
  } else {
    const pos = pagePositions[state.currentPage - 1];
    if (!pos) return;
    const wrapper = document.createElement('div');
    wrapper.className = 'page-wrapper';
    wrapper.id = `page-wrap-${pos.page}`;
    wrapper.dataset.page = pos.page;
    wrapper.style.cssText = `width:${pos.width}px;height:${pos.height}px;position:relative`;

    const label = document.createElement('div');
    label.className = 'page-number-label';
    label.textContent = `Page ${state.currentPage} of ${state.totalPages}`;

    frag.appendChild(wrapper);
    frag.appendChild(label);
  }

  container.appendChild(frag);
}

async function renderVisiblePages(forceRebuild) {
  const state = store.getState();
  if (!state.pdfDoc || state.loading) return;

  // If a render is already running, queue this one so it runs after
  if (_renderingPages) {
    _hasPendingRender = true;
    if (forceRebuild) _pendingRenderForce = true;
    return;
  }
  _renderingPages = true;

  try {
    computePageLayout();
    if (pagePositions.length === 0) { _renderingPages = false; return; }

    buildPagePlaceholders(forceRebuild);

    if (state.continuousScroll) {
      if (forceRebuild) {
        const wrapper = document.getElementById(`page-wrap-${state.currentPage}`);
        if (wrapper) wrapper.scrollIntoView({ block: 'start' });
      }
      await renderVisiblePagesLazy();
    } else {
      await renderSinglePage(state.currentPage);
    }
  } catch (e) {
    console.error('renderVisiblePages error:', e);
  }
  _renderingPages = false;

  // If another render was requested while we were busy, run it now
  if (_hasPendingRender) {
    const force = _pendingRenderForce;
    _hasPendingRender = false;
    _pendingRenderForce = false;
    renderVisiblePages(force);
  }
}

// Deferred text layer queue — renders text/overlays after scroll settles
let _pendingTextLayers = [];
let _textLayerTimer = null;

async function flushTextLayers() {
  const batch = _pendingTextLayers.splice(0);
  for (const { pageNum, wrapper, scale } of batch) {
    if (!renderedPages.has(pageNum)) continue; // page was unloaded
    if (wrapper.querySelector('.text-layer')) continue; // already done
    await engine.renderTextLayer(pageNum, wrapper, scale).catch(() => {});
    renderHighlightsForPage(pageNum, wrapper);
    renderFreehandForPage(pageNum, wrapper);
    setupDrawingForPage(pageNum, wrapper);
    renderSearchHighlightsForPage(pageNum, wrapper);
  }
}

async function renderSinglePage(pageNum) {
  const wrapper = document.getElementById(`page-wrap-${pageNum}`);
  if (!wrapper || renderedPages.has(pageNum)) return;
  renderedPages.add(pageNum);

  // Clear placeholder
  const ph = wrapper.querySelector('.page-placeholder');
  if (ph) ph.remove();

  if (!wrapper.querySelector('canvas')) {
    const cvs = document.createElement('canvas');
    cvs.id = `page-canvas-${pageNum}`;
    wrapper.appendChild(cvs);
  }

  const cvs = wrapper.querySelector('canvas');

  // Render canvas (visual priority)
  try {
    await engine.renderPage(pageNum, cvs, effectiveScale);

    // Correct wrapper size if actual dims differ from assumed (dims already cached by renderPage)
    const dims = engine.pageDimCache.get(pageNum);
    if (dims) {
      const actualH = dims.height * effectiveScale;
      const actualW = dims.width * effectiveScale;
      if (Math.abs(wrapper.clientHeight - actualH) > 2) {
        wrapper.style.width = actualW + 'px';
        wrapper.style.height = actualH + 'px';
      }
    }
  } catch (e) {
    if (e.name !== 'RenderingCancelled') console.error('Page render error:', e);
    return;
  }

  // Defer text layer & overlays — render after scroll settles
  _pendingTextLayers.push({ pageNum, wrapper, scale: effectiveScale });
  clearTimeout(_textLayerTimer);
  _textLayerTimer = setTimeout(flushTextLayers, 180);
}

async function renderVisiblePagesLazy() {
  const canvas = document.getElementById('reading-canvas');
  if (!canvas || pagePositions.length === 0) return;

  const scrollTop = canvas.scrollTop;
  const viewHeight = canvas.clientHeight;
  const buffer = Math.max(viewHeight * 1.5, 800);
  const viewCenter = scrollTop + viewHeight / 2;

  const pagesToRender = [];
  const pagesToUnload = [];

  for (const pos of pagePositions) {
    const pageBottom = pos.top + pos.height;
    const inRange = pageBottom > (scrollTop - buffer) && pos.top < (scrollTop + viewHeight + buffer);

    if (inRange && !renderedPages.has(pos.page)) {
      // Sort key: distance from viewport center (closest first)
      const pageCenter = pos.top + pos.height / 2;
      pagesToRender.push({ page: pos.page, dist: Math.abs(pageCenter - viewCenter) });
    } else if (!inRange && renderedPages.has(pos.page)) {
      const farAway = pos.top > (scrollTop + viewHeight * 4) || pageBottom < (scrollTop - viewHeight * 4);
      if (farAway) pagesToUnload.push(pos.page);
    }
  }

  // Unload far pages to save memory
  for (const p of pagesToUnload) {
    const wrapper = document.getElementById(`page-wrap-${p}`);
    if (wrapper) {
      const pos = pagePositions[p - 1];
      wrapper.innerHTML = `<div class="page-placeholder" style="width:100%;height:100%">${p}</div>`;
      wrapper.style.width = pos.width + 'px';
      wrapper.style.height = pos.height + 'px';
      renderedPages.delete(p);
    }
  }

  // Sort: closest pages to viewport center render first
  pagesToRender.sort((a, b) => a.dist - b.dist);

  // Render visible pages in parallel (max 4 concurrent)
  const BATCH = 4;
  for (let i = 0; i < pagesToRender.length; i += BATCH) {
    await Promise.all(pagesToRender.slice(i, i + BATCH).map(p => renderSinglePage(p.page)));
  }
}

async function renderThumbnails() {
  const state = store.getState();
  if (!state.pdfDoc) return;
  const startPage = Math.max(1, state.currentPage - 5);
  const endPage = Math.min(state.totalPages, state.currentPage + 10);
  for (let i = startPage; i <= endPage; i++) {
    const canvas = document.getElementById(`thumb-canvas-${i}`);
    if (canvas && !canvas.dataset.rendered) {
      canvas.dataset.rendered = 'true';
      engine.renderThumbnail(i, canvas, 60).catch(() => {});
    }
  }
}

// ===== SEARCH HIGHLIGHT RENDERING (on-page yellow overlays) =====
function renderSearchHighlightsForPage(pageNum, wrapper) {
  wrapper.querySelectorAll('.search-page-highlight').forEach(el => el.remove());
  const state = store.getState();
  if (!state.searchOpen || !state.searchQuery || state.searchResults.length === 0) return;

  const pageResults = state.searchResults.filter(r => r.page === pageNum);
  if (pageResults.length === 0) return;

  const textLayer = wrapper.querySelector('.text-layer');
  if (!textLayer) return;

  const query = state.searchQuery.toLowerCase();
  const spans = Array.from(textLayer.querySelectorAll('span'));
  const wRect = wrapper.getBoundingClientRect();

  spans.forEach(span => {
    const text = span.textContent.toLowerCase();
    let idx = text.indexOf(query);
    if (idx === -1) return;

    // Use Range to get precise bounding rects
    const range = document.createRange();
    range.setStart(span.firstChild || span, Math.min(idx, (span.firstChild?.length || 0)));
    range.setEnd(span.firstChild || span, Math.min(idx + query.length, (span.firstChild?.length || 0)));
    const rects = Array.from(range.getClientRects());

    rects.forEach(rect => {
      if (rect.width < 1 || rect.height < 1) return;
      const hl = document.createElement('div');
      hl.className = 'search-page-highlight';
      hl.style.left = (rect.left - wRect.left) + 'px';
      hl.style.top = (rect.top - wRect.top) + 'px';
      hl.style.width = rect.width + 'px';
      hl.style.height = rect.height + 'px';
      wrapper.appendChild(hl);
    });
  });
}

// ===== HIGHLIGHT / ANNOTATION RENDERING =====
function renderHighlightsForPage(pageNum, wrapper) {
  wrapper.querySelectorAll('.highlight-overlay, .note-pin').forEach(el => el.remove());

  const state = store.getState();
  const docId = state.currentDoc?.id;
  const docAnnos = state.annotations[docId] || [];
  const wW = wrapper.clientWidth;
  const wH = wrapper.clientHeight;

  // Render rect-based annotations (highlights, underlines, text-attached notes)
  const rectAnnos = docAnnos.filter(a => a.page === pageNum && a.rects);
  for (const anno of rectAnnos) {
    for (const rect of anno.rects) {
      const overlay = document.createElement('div');
      overlay.className = 'highlight-overlay';
      overlay.dataset.annoId = anno.id;
      overlay.style.left = (rect.xPct * wW) + 'px';
      overlay.style.top = (rect.yPct * wH) + 'px';
      overlay.style.width = (rect.widthPct * wW) + 'px';
      overlay.style.height = (rect.heightPct * wH) + 'px';

      if (anno.type === 'underline') {
        overlay.style.background = 'transparent';
        overlay.style.borderBottom = `2px solid var(--highlight-${anno.color || 'yellow'})`;
      } else if (anno.type === 'strikethrough') {
        overlay.style.background = 'transparent';
        overlay.style.borderTop = `2px solid var(--highlight-${anno.color || 'yellow'})`;
        overlay.style.top = (rect.yPct * wH + rect.heightPct * wH * 0.5) + 'px';
        overlay.style.height = '0px';
      } else {
        overlay.style.background = `var(--highlight-${anno.color || 'yellow'})`;
      }

      if (anno.type === 'note' && anno.content) {
        overlay.style.cursor = 'pointer';
        overlay.title = anno.content;
        overlay.style.pointerEvents = 'auto';
        overlay.addEventListener('click', (e) => { e.stopPropagation(); showNotePopover(anno, overlay, wrapper); });
      } else if (anno.type === 'highlight' || anno.type === 'underline' || anno.type === 'strikethrough') {
        overlay.addEventListener('click', (e) => { e.stopPropagation(); showAnnotationPopover(anno.id, e); });
      }

      wrapper.appendChild(overlay);
    }
  }

  // Render positioned note pins (tap-to-add notes without text selection)
  const pinAnnos = docAnnos.filter(a => a.page === pageNum && a.type === 'note' && a.xPct != null && !a.rects);
  for (const anno of pinAnnos) {
    const pin = document.createElement('div');
    pin.className = 'note-pin';
    pin.style.left = (anno.xPct * wW - 14) + 'px';
    pin.style.top = (anno.yPct * wH - 14) + 'px';
    pin.style.background = `var(--highlight-${anno.color || 'yellow'})`;
    pin.innerHTML = Icons.note.replace(/width="18" height="18"/, 'width="14" height="14"');
    pin.title = anno.content || '';
    pin.addEventListener('click', (e) => { e.stopPropagation(); showNotePopover(anno, pin, wrapper); });
    wrapper.appendChild(pin);
  }
}

// Show a popover with note content, with delete option
function showNotePopover(anno, anchor, wrapper) {
  // Remove any existing popover
  document.querySelectorAll('.note-popover').forEach(el => el.remove());

  const popover = document.createElement('div');
  popover.className = 'note-popover';

  // Position near the anchor
  const wRect = wrapper.getBoundingClientRect();
  const aRect = anchor.getBoundingClientRect();
  let left = aRect.left - wRect.left + aRect.width / 2 - 120;
  let top = aRect.bottom - wRect.top + 6;
  // Keep within bounds
  left = Math.max(4, Math.min(left, wrapper.clientWidth - 248));
  if (top + 200 > wrapper.clientHeight) top = aRect.top - wRect.top - 210;

  popover.style.left = left + 'px';
  popover.style.top = top + 'px';

  const quoteHtml = anno.text ? `<div class="note-popover-quote">${escapeHtml(anno.text.slice(0, 100))}${anno.text.length > 100 ? '...' : ''}</div>` : '';
  popover.innerHTML = `
    ${quoteHtml}
    <div class="note-popover-text">${escapeHtml(anno.content || '')}</div>
    <div class="note-popover-actions">
      <button class="btn-delete" aria-label="Delete note">Delete</button>
      <button class="btn-close" aria-label="Close">Close</button>
    </div>
  `;
  wrapper.appendChild(popover);

  popover.querySelector('.btn-close').addEventListener('click', () => popover.remove());
  popover.querySelector('.btn-delete').addEventListener('click', () => {
    deleteAnnotationById(anno.id);
    renderHighlightsForPage(anno.page, wrapper);
    popover.remove();
    showToast('Note deleted');
  });

  // Close on click outside
  setTimeout(() => {
    document.addEventListener('click', function _closePop(e) {
      if (!popover.contains(e.target) && e.target !== anchor && !anchor.contains(e.target)) {
        popover.remove();
        document.removeEventListener('click', _closePop);
      }
    });
  }, 10);
}

// Annotation inline popover — click a highlight to edit color or delete
function showAnnotationPopover(annoId, event) {
  document.querySelectorAll('.anno-popover').forEach(el => el.remove());
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const anno = (state.annotations[docId] || []).find(a => a.id === annoId);
  if (!anno) return;

  const colors = [
    { key: 'yellow', bg: 'rgba(250,204,21,0.95)' },
    { key: 'green',  bg: 'rgba(74,222,128,0.95)' },
    { key: 'blue',   bg: 'rgba(96,165,250,0.95)' },
    { key: 'pink',   bg: 'rgba(244,114,182,0.95)' },
    { key: 'purple', bg: 'rgba(168,85,247,0.95)' },
  ];

  const popover = document.createElement('div');
  popover.className = 'anno-popover';
  popover.innerHTML = `
    <div class="anno-popover-colors">
      ${colors.map(c => `<button class="anno-popover-color ${anno.color === c.key ? 'active' : ''}"
        data-color="${c.key}" title="${c.key}" style="background:${c.bg}"></button>`).join('')}
    </div>
    <div class="anno-popover-sep"></div>
    <button class="anno-popover-del" title="Delete annotation">✕ Delete</button>
  `;

  // Position near cursor
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  let left = event.clientX - 60;
  let top = event.clientY - 52;
  left = Math.max(8, Math.min(left, vw - 220));
  top = Math.max(8, Math.min(top, vh - 60));
  popover.style.left = left + 'px';
  popover.style.top = top + 'px';
  document.body.appendChild(popover);

  popover.querySelector('.anno-popover-del').addEventListener('click', () => {
    deleteAnnotationById(annoId);
    const wrapper = document.getElementById(`page-wrap-${anno.page}`);
    if (wrapper) renderHighlightsForPage(anno.page, wrapper);
    popover.remove();
    showToast('Annotation deleted');
  });

  popover.querySelectorAll('.anno-popover-color').forEach(btn => {
    btn.addEventListener('click', () => {
      const newColor = btn.dataset.color;
      const s = store.getState();
      const dId = s.currentDoc?.id;
      if (!dId) return;
      const annos = s.annotations[dId] || [];
      const updated = annos.map(a => a.id === annoId ? { ...a, color: newColor } : a);
      store.setState({ annotations: { ...s.annotations, [dId]: updated } });
      store.persistAnnotations();
      const wrapper = document.getElementById(`page-wrap-${anno.page}`);
      if (wrapper) renderHighlightsForPage(anno.page, wrapper);
      popover.remove();
    });
  });

  // Auto-dismiss
  setTimeout(() => {
    document.addEventListener('click', function _close(e) {
      if (!popover.contains(e.target)) {
        popover.remove();
        document.removeEventListener('click', _close);
      }
    });
  }, 10);
}

// Delete a specific annotation by ID
function deleteAnnotationById(annoId) {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const annotations = { ...state.annotations };
  annotations[docId] = (annotations[docId] || []).filter(a => a.id !== annoId);
  store.setState({ annotations });
  store.persistAnnotations();
}

function setupTextSelectionHandler() {
  document.addEventListener('mouseup', (e) => {
    const state = store.getState();
    if (state.view !== 'reader') return;
    if (state.annotationMode === 'pen') return;
    // Don't interfere with toolbar clicks
    if (e.target.closest('.selection-toolbar, .anno-menu, .anno-fab')) return;

    // Short delay to let long-press handler finish first
    setTimeout(() => {
      const selection = window.getSelection();
      if (!selection || selection.isCollapsed) return;
      if (!selection.toString().trim()) return;

      // Check the selection is inside a text layer
      const range = selection.getRangeAt(0);
      const startEl = range.startContainer.nodeType === Node.TEXT_NODE ? range.startContainer.parentElement : range.startContainer;
      if (!startEl?.closest('.text-layer')) return;

      // If annotation mode is active, apply directly
      if (state.annotationMode === 'highlight' || state.annotationMode === 'underline' || state.annotationMode === 'strikethrough' || state.annotationMode === 'note') {
        handleSelectionAction(state.annotationMode);
      } else if (!document.getElementById('selection-toolbar')) {
        // Show toolbar for manual drag-selection
        showSelectionToolbar();
      }
    }, 50);
  });
}

// ===== TAP-TO-ADD-NOTE (positioned notes without text selection) =====
function setupTapToNote() {
  document.addEventListener('click', (e) => {
    const state = store.getState();
    if (state.view !== 'reader' || state.annotationMode !== 'note') return;

    // Don't trigger if clicking on UI elements, existing notes, or popovers
    if (e.target.closest('.note-pin, .note-popover, .anno-menu, .anno-fab, .reader-topbar, .reader-statusbar, .side-panel, .settings-overlay, .search-overlay')) return;

    // Only trigger if there's no text selection (text-selection notes handled in mouseup)
    const selection = window.getSelection();
    if (selection && !selection.isCollapsed && selection.toString().trim()) return;

    // Find the page wrapper that was clicked
    const pageWrapper = e.target.closest('.page-wrapper');
    if (!pageWrapper) return;

    const pageNum = parseInt(pageWrapper.dataset.page);
    if (!pageNum) return;

    const wrapperRect = pageWrapper.getBoundingClientRect();
    const xPct = (e.clientX - wrapperRect.left) / wrapperRect.width;
    const yPct = (e.clientY - wrapperRect.top) / wrapperRect.height;

    // Clamp within page bounds
    if (xPct < 0 || xPct > 1 || yPct < 0 || yPct > 1) return;

    showNoteDialog('', (noteText) => {
      addAnnotation('note', pageNum, { content: noteText, xPct, yPct });
      renderHighlightsForPage(pageNum, pageWrapper);
      showToast('Note added');
    });
  });
}

// ===== LONG-PRESS TO SELECT SENTENCE & SHOW TOOLBAR =====
function setupLongPressHandler() {
  let pressTimer = null;
  let pressX = 0;
  let pressY = 0;
  let moved = false;
  let longPressFired = false;
  let isDraggingSelection = false;
  let anchorSpan = null;
  const LONG_PRESS_MS = 300;
  const MOVE_THRESHOLD = 22;

  function clearPress() {
    if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
  }

  function handlePressStart(e) {
    const state = store.getState();
    if (state.view !== 'reader') return;
    if (state.annotationMode === 'pen') return;

    // Cancel long-press if multi-touch (pinch-to-zoom)
    if (e.touches && e.touches.length > 1) { clearPress(); return; }

    const touch = e.touches ? e.touches[0] : e;
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!target) return;

    // Must be inside a page wrapper (text layer, canvas, or the wrapper itself)
    const pageWrapper = target.closest('.page-wrapper');
    if (!pageWrapper) return;

    // Skip UI elements
    if (target.closest('.selection-toolbar, .anno-menu, .anno-fab, .note-popover, .note-pin, .reader-topbar, .reader-statusbar, .side-panel')) return;

    pressX = touch.clientX;
    pressY = touch.clientY;
    moved = false;
    longPressFired = false;
    isDraggingSelection = false;
    anchorSpan = null;

    pressTimer = setTimeout(() => {
      if (moved) return;
      longPressFired = true;

      // Find the word at the press point and select it as anchor
      const selectedText = selectWordAt(touch.clientX, touch.clientY);
      if (selectedText) {
        isDraggingSelection = true;
        startDragListener(); // Attach non-passive listener only now
        if (navigator.vibrate) navigator.vibrate(25);
        const sel = window.getSelection();
        if (sel && sel.rangeCount > 0) {
          const r = sel.getRangeAt(0);
          anchorSpan = r.startContainer.nodeType === Node.TEXT_NODE ? r.startContainer.parentElement : r.startContainer;
        }
      }
    }, LONG_PRESS_MS);
  }

  // Non-passive drag handler — only attached during active drag-selection
  function handleDragMove(e) {
    if (!isDraggingSelection || !anchorSpan) return;
    e.preventDefault();
    const touch = e.touches ? e.touches[0] : e;
    extendSelectionTo(touch.clientX, touch.clientY, anchorSpan);
    const tb = document.getElementById('selection-toolbar');
    if (tb) { tb.style.opacity = '0.2'; tb.style.pointerEvents = 'none'; }
  }

  function startDragListener() {
    document.addEventListener('touchmove', handleDragMove, { passive: false });
  }
  function stopDragListener() {
    document.removeEventListener('touchmove', handleDragMove);
  }

  function handlePressMove(e) {
    if (!pressTimer && !isDraggingSelection) return;
    const touch = e.touches ? e.touches[0] : e;
    const dx = touch.clientX - pressX;
    const dy = touch.clientY - pressY;
    if (Math.sqrt(dx * dx + dy * dy) > MOVE_THRESHOLD) {
      moved = true;
      clearPress();
    }
  }

  function handlePressEnd() {
    clearPress();
    if (isDraggingSelection) {
      stopDragListener();
      isDraggingSelection = false;
      anchorSpan = null;
      const sel = window.getSelection();
      if (sel && !sel.isCollapsed && sel.toString().trim()) {
        showSelectionToolbar();
      }
    }
  }

  // Suppress native context menu on canvas/wrapper but allow it on text-layer
  // when there is an active text selection (so native selection handles work on mobile)
  document.addEventListener('contextmenu', (e) => {
    if (e.target.closest('.text-layer')) {
      // Allow native context menu if text is selected (enables mobile selection handles)
      const sel = window.getSelection();
      if (sel && !sel.isCollapsed && sel.toString().trim()) return;
    }
    if (e.target.closest('.text-layer') || e.target.closest('.page-wrapper') || e.target.closest('.reading-canvas')) {
      e.preventDefault();
    }
  });

  document.addEventListener('touchstart', handlePressStart, { passive: true });
  document.addEventListener('touchmove', handlePressMove, { passive: true });
  document.addEventListener('touchend', handlePressEnd);
  document.addEventListener('touchcancel', handlePressEnd);
  document.addEventListener('mousedown', (e) => { if (e.button === 0) handlePressStart(e); });
  document.addEventListener('mousemove', handlePressMove);
  document.addEventListener('mouseup', handlePressEnd);
}

// Select the visual line of text at the given point
function selectLineAt(x, y) {
  // Find the nearest text using caretRangeFromPoint (works even when touch
  // hits the canvas underneath, not the transparent text span directly)
  let hitSpan = null;

  // Method 1: caretRangeFromPoint (Chrome, Safari)
  if (document.caretRangeFromPoint) {
    const caret = document.caretRangeFromPoint(x, y);
    if (caret && caret.startContainer) {
      const node = caret.startContainer;
      hitSpan = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      if (hitSpan && hitSpan.tagName !== 'SPAN') hitSpan = hitSpan.closest('.text-layer span');
    }
  }

  // Method 2: caretPositionFromPoint (Firefox)
  if (!hitSpan && document.caretPositionFromPoint) {
    const pos = document.caretPositionFromPoint(x, y);
    if (pos && pos.offsetNode) {
      const node = pos.offsetNode;
      hitSpan = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      if (hitSpan && hitSpan.tagName !== 'SPAN') hitSpan = hitSpan.closest('.text-layer span');
    }
  }

  // Method 3: elementFromPoint fallback
  if (!hitSpan) {
    const target = document.elementFromPoint(x, y);
    if (target) hitSpan = target.closest('.text-layer span');
  }

  if (!hitSpan) return null;

  const textLayer = hitSpan.closest('.text-layer');
  if (!textLayer) return null;

  // Get the hit span's vertical center
  const hitRect = hitSpan.getBoundingClientRect();
  const hitYCenter = hitRect.top + hitRect.height / 2;
  const tolerance = Math.max(hitRect.height * 0.7, 8);

  // Collect all spans on the same visual line
  const lineSpans = [];
  const allSpans = textLayer.querySelectorAll('span');
  for (const span of allSpans) {
    if (!span.textContent.trim()) continue;
    const r = span.getBoundingClientRect();
    if (r.width === 0 || r.height === 0) continue;
    const yCenter = r.top + r.height / 2;
    if (Math.abs(yCenter - hitYCenter) <= tolerance) {
      lineSpans.push({ span, left: r.left });
    }
  }

  if (lineSpans.length === 0) return null;

  // Sort by horizontal position (left to right)
  lineSpans.sort((a, b) => a.left - b.left);

  // Select from first to last span on the line
  const firstSpan = lineSpans[0].span;
  const lastSpan = lineSpans[lineSpans.length - 1].span;
  const firstNode = firstSpan.firstChild;
  const lastNode = lastSpan.firstChild;
  if (!firstNode || !lastNode) return null;

  const range = document.createRange();
  range.setStart(firstNode, 0);
  range.setEnd(lastNode, lastNode.textContent.length);

  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);

  return selection.toString().trim() || null;
}

// Select the word at the given point (for initial long-press on mobile)
function selectWordAt(x, y) {
  let hitSpan = null;

  if (document.caretRangeFromPoint) {
    const caret = document.caretRangeFromPoint(x, y);
    if (caret && caret.startContainer) {
      const node = caret.startContainer;
      hitSpan = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      if (hitSpan && hitSpan.tagName !== 'SPAN') hitSpan = hitSpan.closest('.text-layer span');
    }
  }

  if (!hitSpan && document.caretPositionFromPoint) {
    const pos = document.caretPositionFromPoint(x, y);
    if (pos && pos.offsetNode) {
      const node = pos.offsetNode;
      hitSpan = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      if (hitSpan && hitSpan.tagName !== 'SPAN') hitSpan = hitSpan.closest('.text-layer span');
    }
  }

  if (!hitSpan) {
    const target = document.elementFromPoint(x, y);
    if (target) hitSpan = target.closest('.text-layer span');
  }

  if (!hitSpan || !hitSpan.closest('.text-layer')) return null;

  const textNode = hitSpan.firstChild;
  if (!textNode) return null;

  // Find the character offset at the touch point
  let charOffset = 0;
  if (document.caretRangeFromPoint) {
    const caret = document.caretRangeFromPoint(x, y);
    if (caret && caret.startContainer === textNode) charOffset = caret.startOffset;
  } else if (document.caretPositionFromPoint) {
    const pos = document.caretPositionFromPoint(x, y);
    if (pos && pos.offsetNode === textNode) charOffset = pos.offset;
  }

  const text = textNode.textContent;
  // Expand to word boundaries
  let start = charOffset, end = charOffset;
  while (start > 0 && /\S/.test(text[start - 1])) start--;
  while (end < text.length && /\S/.test(text[end])) end++;

  // If we didn't find a word, select the whole span
  if (start === end) { start = 0; end = text.length; }

  const range = document.createRange();
  range.setStart(textNode, start);
  range.setEnd(textNode, end);

  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);

  return selection.toString().trim() || null;
}

// Extend selection from the anchor span to wherever the finger is dragging
function extendSelectionTo(x, y, anchor) {
  let hitSpan = null;

  if (document.caretRangeFromPoint) {
    const caret = document.caretRangeFromPoint(x, y);
    if (caret && caret.startContainer) {
      const node = caret.startContainer;
      hitSpan = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      if (hitSpan && hitSpan.tagName !== 'SPAN') hitSpan = hitSpan.closest('.text-layer span');
    }
  }

  if (!hitSpan && document.caretPositionFromPoint) {
    const pos = document.caretPositionFromPoint(x, y);
    if (pos && pos.offsetNode) {
      const node = pos.offsetNode;
      hitSpan = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      if (hitSpan && hitSpan.tagName !== 'SPAN') hitSpan = hitSpan.closest('.text-layer span');
    }
  }

  if (!hitSpan) {
    const target = document.elementFromPoint(x, y);
    if (target) hitSpan = target.closest('.text-layer span');
  }

  if (!hitSpan || !anchor) return;

  const textLayer = hitSpan.closest('.text-layer');
  if (!textLayer || !textLayer.contains(anchor)) return;

  const anchorNode = anchor.firstChild;
  const hitNode = hitSpan.firstChild;
  if (!anchorNode || !hitNode) return;

  // Find character offset in hit span
  let hitOffset = hitNode.textContent.length;
  if (document.caretRangeFromPoint) {
    const caret = document.caretRangeFromPoint(x, y);
    if (caret && caret.startContainer === hitNode) hitOffset = caret.startOffset;
  } else if (document.caretPositionFromPoint) {
    const pos = document.caretPositionFromPoint(x, y);
    if (pos && pos.offsetNode === hitNode) hitOffset = pos.offset;
  }

  // Determine direction: anchor before or after hit
  const anchorRect = anchor.getBoundingClientRect();
  const hitRect = hitSpan.getBoundingClientRect();

  const range = document.createRange();
  if (anchorRect.top < hitRect.top || (anchorRect.top === hitRect.top && anchorRect.left <= hitRect.left)) {
    range.setStart(anchorNode, 0);
    range.setEnd(hitNode, hitOffset);
  } else {
    range.setStart(hitNode, hitOffset);
    range.setEnd(anchorNode, anchorNode.textContent.length);
  }

  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
}

// Show floating toolbar positioned near the current selection
function showSelectionToolbar() {
  dismissSelectionToolbar();

  const selection = window.getSelection();
  if (!selection || selection.isCollapsed) return;
  if (!selection.toString().trim()) return;

  const range = selection.getRangeAt(0);
  const selRect = range.getBoundingClientRect();
  if (selRect.width === 0 && selRect.height === 0) return;

  const state = store.getState();
  const currentColor = state.highlightColor;
  const colorDefs = [
    { key: 'yellow', bg: 'rgba(250,204,21,0.95)' },
    { key: 'green',  bg: 'rgba(74,222,128,0.95)' },
    { key: 'blue',   bg: 'rgba(96,165,250,0.95)' },
    { key: 'pink',   bg: 'rgba(244,114,182,0.95)' },
    { key: 'purple', bg: 'rgba(168,85,247,0.95)' },
  ];

  const toolbar = document.createElement('div');
  toolbar.className = 'selection-toolbar';
  toolbar.id = 'selection-toolbar';
  toolbar.style.flexDirection = 'column';
  toolbar.style.padding = '0';
  toolbar.innerHTML = `
    <div class="sel-tb-actions">
      <button data-action="highlight" aria-label="Highlight">${Icons.highlight} Highlight</button>
      <div class="sel-tb-sep"></div>
      <button data-action="note" aria-label="Add note">${Icons.note} Note</button>
      <div class="sel-tb-sep"></div>
      <button data-action="copy" aria-label="Copy">${Icons.copy} Copy</button>
    </div>
    <div class="sel-tb-colors">
      ${colorDefs.map(c => `<button class="sel-color-btn ${currentColor === c.key ? 'active' : ''}"
          data-action="color" data-color="${c.key}" title="${c.key}" aria-label="${c.key}"
          style="background:${c.bg}"></button>`).join('')}
    </div>
  `;
  document.body.appendChild(toolbar);

  // Position above the selection, centered
  const tw = toolbar.offsetWidth;
  const th = toolbar.offsetHeight;
  let left = selRect.left + selRect.width / 2 - tw / 2;
  let top = selRect.top - th - 10;

  left = Math.max(8, Math.min(left, window.innerWidth - tw - 8));
  if (top < 8) top = selRect.bottom + 10;
  // If toolbar would go below viewport, push it above selection
  if (top + th > window.innerHeight - 8) top = Math.max(8, selRect.top - th - 10);

  toolbar.style.left = left + 'px';
  toolbar.style.top = top + 'px';

  toolbar.addEventListener('click', (e) => {
    const btn = e.target.closest('button[data-action]');
    if (!btn) return;
    e.stopPropagation();
    if (btn.dataset.action === 'color') {
      // Update color and refresh dots
      const newColor = btn.dataset.color;
      store.setState({ highlightColor: newColor });
      toolbar.querySelectorAll('.sel-color-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.color === newColor);
      });
    } else {
      handleSelectionAction(btn.dataset.action);
    }
  });

  setTimeout(() => {
    document.addEventListener('pointerdown', _dismissOnOutside);
    document.addEventListener('scroll', _dismissOnScroll, { capture: true });
  }, 100);
}

function _dismissOnOutside(e) {
  const toolbar = document.getElementById('selection-toolbar');
  if (toolbar && !toolbar.contains(e.target)) {
    // Don't dismiss if the user is tapping inside the text layer (may be adjusting selection handles)
    if (e.target.closest('.text-layer')) {
      const sel = window.getSelection();
      if (sel && !sel.isCollapsed) return;
    }
    dismissSelectionToolbar();
  }
}
let _scrollDismissTimer = null;
function _dismissOnScroll() {
  // Debounce scroll dismissal so small scroll adjustments don't kill the selection
  clearTimeout(_scrollDismissTimer);
  _scrollDismissTimer = setTimeout(() => dismissSelectionToolbar(), 600);
}

function dismissSelectionToolbar() {
  const toolbar = document.getElementById('selection-toolbar');
  if (toolbar) toolbar.remove();
  document.removeEventListener('pointerdown', _dismissOnOutside);
  document.removeEventListener('scroll', _dismissOnScroll, { capture: true });
  // Clear selection to remove blue highlights from text layer
  window.getSelection()?.removeAllRanges();
}

function handleSelectionAction(action) {
  const selection = window.getSelection();
  if (!selection || selection.isCollapsed) { dismissSelectionToolbar(); return; }

  const selectedText = selection.toString().trim();
  if (!selectedText) { dismissSelectionToolbar(); return; }

  const range = selection.getRangeAt(0);
  const startEl = range.startContainer.nodeType === Node.TEXT_NODE ? range.startContainer.parentElement : range.startContainer;
  const textLayer = startEl?.closest('.text-layer');
  const pageWrapper = textLayer?.closest('.page-wrapper');
  if (!pageWrapper) { dismissSelectionToolbar(); return; }

  const pageNum = parseInt(pageWrapper.dataset.page);
  if (!pageNum) { dismissSelectionToolbar(); return; }

  // Get rects relative to the page wrapper, filtering out tiny/empty ones
  const wrapperRect = pageWrapper.getBoundingClientRect();
  const wW = wrapperRect.width;
  const wH = wrapperRect.height;
  const rawRects = Array.from(range.getClientRects());
  const relativeRects = rawRects
    .filter(r => r.width > 2 && r.height > 2)
    .map(r => ({
      xPct: Math.max(0, (r.left - wrapperRect.left) / wW),
      yPct: Math.max(0, (r.top - wrapperRect.top) / wH),
      widthPct: Math.min(1, r.width / wW),
      heightPct: Math.min(1, r.height / wH),
    }))
    .filter(r => r.widthPct > 0.001 && r.heightPct > 0.001);

  if (relativeRects.length === 0) { dismissSelectionToolbar(); return; }

  dismissSelectionToolbar();

  if (action === 'highlight') {
    addAnnotation('highlight', pageNum, { text: selectedText, rects: relativeRects });
    renderHighlightsForPage(pageNum, pageWrapper);
    showToast('Highlighted');
  } else if (action === 'note') {
    showNoteDialog(selectedText, (noteText) => {
      addAnnotation('note', pageNum, { text: selectedText, content: noteText, rects: relativeRects });
      renderHighlightsForPage(pageNum, pageWrapper);
      showToast('Note saved');
    });
  } else if (action === 'copy') {
    navigator.clipboard?.writeText(selectedText).then(() => showToast('Copied'));
  }
}

// ===== FREEHAND DRAWING =====
function renderFreehandForPage(pageNum, wrapper) {
  const existing = wrapper.querySelector('.freehand-canvas');
  if (existing) existing.remove();

  const state = store.getState();
  const docId = state.currentDoc?.id;
  const docAnnos = state.annotations[docId] || [];
  const freehandAnnos = docAnnos.filter(a => a.page === pageNum && a.type === 'freehand' && a.points);

  if (freehandAnnos.length === 0) return;

  const cvs = document.createElement('canvas');
  cvs.className = 'freehand-canvas';
  cvs.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;';
  cvs.width = wrapper.clientWidth * (window.devicePixelRatio || 1);
  cvs.height = wrapper.clientHeight * (window.devicePixelRatio || 1);
  const ctx = cvs.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const wW = wrapper.clientWidth;
  const wH = wrapper.clientHeight;

  const colorMap = {
    yellow: 'rgba(255,213,79,0.7)', green: 'rgba(102,187,106,0.7)',
    blue: 'rgba(66,165,245,0.7)', pink: 'rgba(240,98,146,0.7)', purple: 'rgba(171,130,255,0.7)'
  };

  for (const anno of freehandAnnos) {
    if (anno.points.length < 2) continue;
    ctx.beginPath();
    ctx.strokeStyle = colorMap[anno.color] || colorMap.yellow;
    ctx.lineWidth = 2 * dpr;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    const first = anno.points[0];
    ctx.moveTo(first.xPct * wW * dpr, first.yPct * wH * dpr);
    for (let i = 1; i < anno.points.length; i++) {
      const pt = anno.points[i];
      ctx.lineTo(pt.xPct * wW * dpr, pt.yPct * wH * dpr);
    }
    ctx.stroke();
  }

  wrapper.appendChild(cvs);
}

function setupDrawingForPage(pageNum, wrapper) {
  const existingDraw = wrapper.querySelector('.drawing-canvas');
  if (existingDraw) existingDraw.remove();

  // Only create if pen or eraser mode
  const state = store.getState();
  if (state.annotationMode !== 'pen' && state.annotationMode !== 'eraser') return;

  // Eraser mode: click/drag to erase freehand strokes near cursor
  if (state.annotationMode === 'eraser') {
    const eraserCvs = document.createElement('canvas');
    eraserCvs.className = 'drawing-canvas';
    eraserCvs.width = wrapper.clientWidth * (window.devicePixelRatio || 1);
    eraserCvs.height = wrapper.clientHeight * (window.devicePixelRatio || 1);
    eraserCvs.style.cursor = 'cell';
    const wW = wrapper.clientWidth;
    const wH = wrapper.clientHeight;
    const eraseRadius = 20; // px

    const eraseAt = (ex, ey) => {
      const s = store.getState();
      const docId = s.currentDoc?.id;
      if (!docId) return;
      const annos = s.annotations[docId] || [];
      const xPct = ex / wW;
      const yPct = ey / wH;
      const updated = annos.filter(a => {
        if (a.page !== pageNum || a.type !== 'freehand' || !a.points) return true;
        // Check if any point is within eraseRadius
        return !a.points.some(pt =>
          Math.hypot((pt.xPct - xPct) * wW, (pt.yPct - yPct) * wH) < eraseRadius
        );
      });
      if (updated.length !== annos.length) {
        const allAnnos = { ...s.annotations, [docId]: updated };
        store.setState({ annotations: allAnnos });
        store.persistAnnotations();
        renderFreehandForPage(pageNum, wrapper);
      }
    };

    let erasing = false;
    eraserCvs.addEventListener('pointerdown', (e) => {
      erasing = true;
      eraserCvs.setPointerCapture(e.pointerId);
      const rect = eraserCvs.getBoundingClientRect();
      eraseAt(e.clientX - rect.left, e.clientY - rect.top);
    });
    eraserCvs.addEventListener('pointermove', (e) => {
      if (!erasing) return;
      const rect = eraserCvs.getBoundingClientRect();
      eraseAt(e.clientX - rect.left, e.clientY - rect.top);
    });
    eraserCvs.addEventListener('pointerup', () => { erasing = false; });
    wrapper.appendChild(eraserCvs);
    return;
  }

  const drawCvs = document.createElement('canvas');
  drawCvs.className = 'drawing-canvas';
  drawCvs.width = wrapper.clientWidth * (window.devicePixelRatio || 1);
  drawCvs.height = wrapper.clientHeight * (window.devicePixelRatio || 1);
  const ctx = drawCvs.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const wW = wrapper.clientWidth;
  const wH = wrapper.clientHeight;

  let drawing = false;
  let currentPath = [];

  const colorMap = {
    yellow: 'rgba(255,213,79,0.8)', green: 'rgba(102,187,106,0.8)',
    blue: 'rgba(66,165,245,0.8)', pink: 'rgba(240,98,146,0.8)', purple: 'rgba(171,130,255,0.8)'
  };

  drawCvs.addEventListener('pointerdown', (e) => {
    drawing = true;
    const rect = drawCvs.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    currentPath = [{ xPct: x / wW, yPct: y / wH }];
    ctx.beginPath();
    ctx.strokeStyle = colorMap[store.getState().highlightColor] || colorMap.yellow;
    ctx.lineWidth = 2 * dpr;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.moveTo(x * dpr, y * dpr);
    drawCvs.setPointerCapture(e.pointerId);
  });

  drawCvs.addEventListener('pointermove', (e) => {
    if (!drawing) return;
    const rect = drawCvs.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    currentPath.push({ xPct: x / wW, yPct: y / wH });
    ctx.lineTo(x * dpr, y * dpr);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x * dpr, y * dpr);
  });

  drawCvs.addEventListener('pointerup', () => {
    if (!drawing) return;
    drawing = false;
    if (currentPath.length > 1) {
      addAnnotation('freehand', pageNum, {
        points: currentPath,
        color: store.getState().highlightColor,
      });
      // Re-render freehand layer
      renderFreehandForPage(pageNum, wrapper);
    }
    // Clear drawing canvas
    ctx.clearRect(0, 0, drawCvs.width, drawCvs.height);
  });

  wrapper.appendChild(drawCvs);
}

// ===== EVENT HANDLERS =====
function attachLibraryEvents() {
  document.getElementById('btn-open-file')?.addEventListener('click', promptFileOpen);
  document.getElementById('btn-open-empty')?.addEventListener('click', promptFileOpen);

  document.getElementById('btn-settings-lib')?.addEventListener('click', () => {
    store.setState({ settingsOpen: true });
  });

  // Doc card clicks
  document.querySelectorAll('.doc-card').forEach(card => {
    card.addEventListener('click', (e) => {
      // Ignore if delete button was clicked
      if (e.target.closest('.doc-card-delete')) return;
      const docId = card.dataset.docId;
      handleOpenFromLibrary(docId);
    });
  });

  // Doc card delete buttons
  document.querySelectorAll('.doc-card-delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const docId = btn.dataset.deleteId;
      if (confirm('Remove this document from your library?')) {
        deleteDocument(docId);
      }
    });
  });

  // Library search
  document.getElementById('lib-search-input')?.addEventListener('input', (e) => {
    const query = e.target.value.toLowerCase();
    document.querySelectorAll('.doc-card').forEach(card => {
      const title = card.querySelector('.doc-card-title')?.textContent?.toLowerCase() || '';
      card.style.display = title.includes(query) ? '' : 'none';
    });
  });

  // Drag & Drop
  setupDragDrop();
  attachSettingsEvents();
}

function setupDragDrop() {
  document.addEventListener('dragover', (e) => { e.preventDefault(); store.setState({ isDragging: true }); });
  document.addEventListener('dragleave', (e) => {
    if (e.relatedTarget === null) store.setState({ isDragging: false });
  });
  document.addEventListener('drop', (e) => {
    e.preventDefault();
    store.setState({ isDragging: false });
    const file = e.dataTransfer.files[0];
    if (file) handleFileOpen(file);
  });
}

function attachReaderEvents() {
  document.getElementById('btn-back')?.addEventListener('click', () => {
    saveReadingProgress();
    store.setState({ view: 'library', sidePanel: false, searchOpen: false, focusMode: false, annotationMode: null });
  });

  document.getElementById('btn-sidebar')?.addEventListener('click', () => {
    store.setState({ sidePanel: !store.getState().sidePanel });
  });

  // Mobile sidebar backdrop
  document.getElementById('sidebar-backdrop')?.addEventListener('click', () => {
    store.setState({ sidePanel: false });
  });

  document.getElementById('btn-zoom-in')?.addEventListener('click', () => {
    nudgeZoom(1, { renderMode: 'immediate' });
  });

  document.getElementById('btn-zoom-out')?.addEventListener('click', () => {
    nudgeZoom(-1, { renderMode: 'immediate' });
  });

  document.getElementById('btn-search')?.addEventListener('click', () => {
    store.setState({ searchOpen: !store.getState().searchOpen });
  });

  document.getElementById('btn-bookmark')?.addEventListener('click', toggleBookmark);
  document.getElementById('btn-focus')?.addEventListener('click', () => {
    store.setState({ focusMode: !store.getState().focusMode });
  });
  document.getElementById('btn-settings')?.addEventListener('click', () => {
    store.setState({ settingsOpen: true });
  });
  document.getElementById('btn-download')?.addEventListener('click', async () => {
    const s = store.getState();
    if (!s.currentDoc) return;
    try {
      const ab = await docStorage.getFile(s.currentDoc.id);
      if (!ab) { showToast('File not found in local storage.'); return; }
      const blob = new Blob([ab], { type: 'application/pdf' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = s.currentDoc.name.endsWith('.pdf') ? s.currentDoc.name : s.currentDoc.name + '.pdf';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast('Download started');
    } catch (e) {
      showToast('Download failed.');
    }
  });

  document.getElementById('page-slider')?.addEventListener('input', (e) => {
    goToPage(parseInt(e.target.value));
  });

  // Prev/Next page navigation
  document.getElementById('btn-prev-page')?.addEventListener('click', () => {
    const s = store.getState();
    if (s.currentPage > 1) goToPage(s.currentPage - 1);
  });
  document.getElementById('btn-next-page')?.addEventListener('click', () => {
    const s = store.getState();
    if (s.currentPage < s.totalPages) goToPage(s.currentPage + 1);
  });

  // Page jump — click page number to edit
  document.getElementById('page-jump-display')?.addEventListener('click', () => {
    const s = store.getState();
    const display = document.getElementById('page-jump-display');
    if (!display) return;
    const input = document.createElement('input');
    input.type = 'number';
    input.className = 'page-jump-input';
    input.value = s.currentPage;
    input.min = 1;
    input.max = s.totalPages;
    input.setAttribute('aria-label', 'Go to page');
    display.replaceWith(input);
    input.focus();
    input.select();
    const commit = () => {
      const page = Math.max(1, Math.min(s.totalPages, parseInt(input.value) || s.currentPage));
      goToPage(page);
      // replace input back with display (re-render will handle it)
    };
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') { commit(); input.blur(); }
      if (e.key === 'Escape') { input.blur(); }
    });
    input.addEventListener('blur', commit);
  });

  // Side panel tabs
  document.querySelectorAll('.sp-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      store.setState({ sidePanelTab: tab.dataset.sptab });
    });
  });

  document.getElementById('sp-content')?.addEventListener('click', (e) => {
    const item = e.target.closest('[data-page]');
    if (item) goToPage(parseInt(item.dataset.page));
    const removeBtn = e.target.closest('[data-remove-bm]');
    if (removeBtn) {
      e.stopPropagation();
      removeBookmark(parseInt(removeBtn.dataset.removeBm));
    }
  });

  // Search
  const searchInput = document.getElementById('search-input');
  let searchTimeout;
  searchInput?.addEventListener('input', (e) => {
    clearTimeout(searchTimeout);
    const query = e.target.value;
    store.setState({ searchQuery: query });
    searchTimeout = setTimeout(async () => {
      if (query.length >= 2) {
        const results = await engine.searchText(query);
        store.setState({ searchResults: results });
        refreshSearchHighlights();
      } else {
        store.setState({ searchResults: [] });
        refreshSearchHighlights();
      }
    }, 300);
  });

  document.getElementById('btn-close-search')?.addEventListener('click', () => {
    store.setState({ searchOpen: false, searchQuery: '', searchResults: [] });
    refreshSearchHighlights();
  });

  document.getElementById('search-results')?.addEventListener('click', (e) => {
    const item = e.target.closest('[data-page]');
    if (item) goToPage(parseInt(item.dataset.page));
  });

  // ===== ANNOTATION BAR events =====
  document.getElementById('bar-btn-highlight')?.addEventListener('click', () => {
    toggleAnnotationMode('highlight');
  });
  document.getElementById('bar-btn-underline')?.addEventListener('click', () => {
    toggleAnnotationMode('underline');
  });
  document.getElementById('bar-btn-strikethrough')?.addEventListener('click', () => {
    toggleAnnotationMode('strikethrough');
  });
  document.getElementById('bar-btn-note')?.addEventListener('click', () => {
    toggleAnnotationMode('note');
    refreshDrawingCanvases();
  });
  document.getElementById('bar-btn-pen')?.addEventListener('click', () => {
    toggleAnnotationMode('pen');
    refreshDrawingCanvases();
  });
  document.getElementById('bar-btn-eraser')?.addEventListener('click', () => {
    toggleAnnotationMode('eraser');
    refreshDrawingCanvases();
  });
  document.getElementById('bar-btn-undo')?.addEventListener('click', undoAnnotation);

  // Color swatches in anno-bar
  document.querySelectorAll('#anno-bar .color-swatch').forEach(btn => {
    btn.addEventListener('click', () => store.setState({ highlightColor: btn.dataset.color }));
  });

  // Scroll-driven lazy rendering + auto-hide topbar
  const readingCanvas = document.getElementById('reading-canvas');
  const topbarEl = document.querySelector('.reader-topbar');
  let lastScrollTop = 0;
  let lazyRenderTimer = null;

  readingCanvas?.addEventListener('scroll', () => {
    // Lightweight: topbar show/hide (no layout queries, just classList)
    const st = readingCanvas.scrollTop;
    if (topbarEl) {
      if (st > lastScrollTop && st > 80) topbarEl.classList.add('scroll-hidden');
      else if (st < lastScrollTop) topbarEl.classList.remove('scroll-hidden');
    }
    lastScrollTop = st <= 0 ? 0 : st;

    // Throttled: page detection + lazy rendering (runs max every 60ms)
    if (!lazyRenderTimer) {
      lazyRenderTimer = setTimeout(() => {
        lazyRenderTimer = null;
        updateCurrentPageFromScroll();
        if (store.getState().continuousScroll) renderVisiblePagesLazy();
      }, 60);
    }
  }, { passive: true });

  // Tap canvas to show topbar if hidden
  readingCanvas?.addEventListener('click', (e) => {
    if (e.target.closest('.selection-toolbar, .note-pin, .note-popover')) return;
    const topbar = document.querySelector('.reader-topbar');
    if (topbar?.classList.contains('scroll-hidden')) {
      topbar.classList.remove('scroll-hidden');
    }
  });

  // Ctrl/Cmd + wheel zoom around cursor (desktop + trackpad pinch gestures)
  let wheelZoomRAF = null;
  let wheelZoomDelta = 0;
  let wheelAnchorX = null;
  let wheelAnchorY = null;
  const flushWheelZoom = () => {
    wheelZoomRAF = null;
    if (Math.abs(wheelZoomDelta) < 0.01) return;
    const factor = Math.exp(-wheelZoomDelta * 0.00145);
    wheelZoomDelta = 0;
    setZoomLevel(store.getState().zoom * factor, {
      renderMode: 'debounced',
      anchorClientX: wheelAnchorX,
      anchorClientY: wheelAnchorY,
    });
  };

  readingCanvas?.addEventListener('wheel', (e) => {
    if (!(e.ctrlKey || e.metaKey)) return;
    e.preventDefault();
    const unit = e.deltaMode === 1 ? 16 : (e.deltaMode === 2 ? Math.max(readingCanvas.clientHeight, 1) : 1);
    wheelZoomDelta += e.deltaY * unit;
    wheelAnchorX = e.clientX;
    wheelAnchorY = e.clientY;
    if (!wheelZoomRAF) wheelZoomRAF = requestAnimationFrame(flushWheelZoom);
  }, { passive: false });

  setCommittedZoom(store.getState().zoom);
  syncZoomIndicators();

  // Keyboard
  document.addEventListener('keydown', handleKeyboard);

  // Ruler
  if (store.getState().showRuler) {
    document.addEventListener('mousemove', (e) => {
      if (store.getState().showRuler) {
        const r = document.querySelector('.reading-ruler');
        if (r) r.style.top = e.clientY + 'px';
      }
    });
  }

  // Pinch-to-zoom
  setupPinchZoom(readingCanvas);

  // Swipe navigation (single-page mode)
  setupSwipeNavigation(readingCanvas);

  // Render pages — defer to next frame so the browser has laid out the DOM
  if (store.getState().pdfDoc && !store.getState().loading) {
    // Reset layout tracking so placeholders get built fresh
    _builtScale = null;
    requestAnimationFrame(() => {
      renderVisiblePages(true);
      if (store.getState().sidePanel && store.getState().sidePanelTab === 'thumbnails') {
        setTimeout(renderThumbnails, 200);
      }
    });
  }

  attachSettingsEvents();
  setupDragDrop();

  // Sync anno-bar active states after re-render
  updateAnnoBar(store.getState());
}

function refreshDrawingCanvases() {
  for (const p of renderedPages) {
    const wrapper = document.getElementById(`page-wrap-${p}`);
    if (wrapper) setupDrawingForPage(p, wrapper);
  }
}

function refreshSearchHighlights() {
  for (const p of renderedPages) {
    const wrapper = document.getElementById(`page-wrap-${p}`);
    if (wrapper) renderSearchHighlightsForPage(p, wrapper);
  }
}

function attachSettingsEvents() {
  document.getElementById('modal-overlay')?.addEventListener('click', (e) => {
    if (e.target.id === 'modal-overlay') store.setState({ settingsOpen: false });
  });
  document.getElementById('btn-close-settings')?.addEventListener('click', () => {
    store.setState({ settingsOpen: false });
  });
  document.querySelectorAll('.theme-option[data-theme]').forEach(btn => {
    btn.addEventListener('click', () => store.setTheme(btn.dataset.theme));
  });
  document.getElementById('toggle-scroll')?.addEventListener('click', () => {
    store.setState({ continuousScroll: !store.getState().continuousScroll });
    if (store.getState().view === 'reader') renderVisiblePages();
  });
  document.getElementById('toggle-annobar')?.addEventListener('click', () => {
    store.setState({ showAnnotationBar: !store.getState().showAnnotationBar });
  });
  document.getElementById('toggle-ruler')?.addEventListener('click', () => {
    store.setState({ showRuler: !store.getState().showRuler });
  });
  document.querySelectorAll('.zoom-preset-btn[data-zoom-preset]').forEach(btn => {
    btn.addEventListener('click', () => {
      const v = btn.dataset.zoomPreset;
      if (v === 'fit') {
        setZoomLevel(1, { renderMode: 'immediate' });
      } else {
        setZoomLevel(parseFloat(v), { renderMode: 'immediate' });
      }
    });
  });
}

// ===== ANNOTATION BAR (direct DOM updates — no re-render needed) =====
function updateAnnoBar(state) {
  // Update tool button active states
  ['highlight', 'underline', 'strikethrough', 'note', 'pen', 'eraser'].forEach(m => {
    const btn = document.getElementById(`bar-btn-${m}`);
    if (btn) {
      btn.classList.toggle('active', state.annotationMode === m);
      btn.setAttribute('aria-pressed', state.annotationMode === m);
    }
  });
  // Update color swatches
  document.querySelectorAll('#anno-bar .color-swatch').forEach(dot => {
    dot.classList.toggle('active', dot.dataset.color === state.highlightColor);
    dot.setAttribute('aria-pressed', dot.dataset.color === state.highlightColor);
  });
}

// Legacy stub kept for compatibility — now a no-op
function updateAnnoMenu(state) {
  updateAnnoBar(state);
}

// ===== MOBILE: PINCH-TO-ZOOM =====
function setupPinchZoom(el) {
  if (!el) return;
  let initialDistance = 0;
  let initialZoom = 1;
  let pinching = false;
  let pinchRAF = null;
  let queuedScale = 1;
  let queuedCenterX = 0;
  let queuedCenterY = 0;

  function flushPinchZoom() {
    pinchRAF = null;
    setZoomLevel(initialZoom * queuedScale, {
      renderMode: 'debounced',
      anchorClientX: queuedCenterX,
      anchorClientY: queuedCenterY,
    });
  }

  // Non-passive handler — only attached while 2 fingers are down
  function onPinchMove(e) {
    if (e.touches.length < 2) return;
    e.preventDefault();
    const dist = Math.sqrt(
      (e.touches[1].clientX - e.touches[0].clientX) ** 2 +
      (e.touches[1].clientY - e.touches[0].clientY) ** 2
    );
    if (initialDistance <= 0) return;
    queuedScale = dist / initialDistance;
    queuedCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    queuedCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    if (!pinchRAF) pinchRAF = requestAnimationFrame(flushPinchZoom);
  }

  function stopPinch() {
    if (!pinching) return;
    pinching = false;
    if (pinchRAF) {
      cancelAnimationFrame(pinchRAF);
      pinchRAF = null;
      flushPinchZoom();
    }
    el.removeEventListener('touchmove', onPinchMove);
  }

  el.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2 && !pinching) {
      pinching = true;
      initialDistance = Math.sqrt(
        (e.touches[1].clientX - e.touches[0].clientX) ** 2 +
        (e.touches[1].clientY - e.touches[0].clientY) ** 2
      );
      initialZoom = store.getState().zoom;
      queuedScale = 1;
      queuedCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      queuedCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
      el.addEventListener('touchmove', onPinchMove, { passive: false });
    }
  }, { passive: true });

  el.addEventListener('touchend', (e) => {
    if (e.touches.length < 2) stopPinch();
  }, { passive: true });
  el.addEventListener('touchcancel', () => {
    stopPinch();
  }, { passive: true });
}

// ===== MOBILE: SWIPE NAVIGATION =====
function setupSwipeNavigation(el) {
  if (!el) return;
  let startX = 0;
  let startY = 0;

  el.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
    }
  }, { passive: true });

  el.addEventListener('touchend', (e) => {
    if (store.getState().continuousScroll) return;
    const endX = e.changedTouches[0].clientX;
    const endY = e.changedTouches[0].clientY;
    const dx = endX - startX;
    const dy = endY - startY;

    if (Math.abs(dx) > 60 && Math.abs(dx) > Math.abs(dy) * 2) {
      if (dx < 0) goToPage(store.getState().currentPage + 1);
      else goToPage(store.getState().currentPage - 1);
    }
  }, { passive: true });
}

// ===== NAVIGATION =====
function goToPage(page) {
  const state = store.getState();
  page = Math.max(1, Math.min(page, state.totalPages));
  if (page === state.currentPage && state.continuousScroll) {
    const wrapper = document.getElementById(`page-wrap-${page}`);
    if (wrapper) wrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
    return;
  }
  store.setState({ currentPage: page });

  if (state.continuousScroll) {
    const wrapper = document.getElementById(`page-wrap-${page}`);
    if (wrapper) {
      wrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
      renderVisiblePagesLazy();
    } else {
      renderVisiblePages();
    }
  } else {
    renderVisiblePages();
  }
  saveReadingProgress();
  updateStatusBar(page);
}

function updateCurrentPageFromScroll() {
  const container = document.getElementById('reading-canvas');
  if (!container || pagePositions.length === 0) return;

  const scrollTop = container.scrollTop + container.clientHeight / 3;
  const currentPage = store.getState().currentPage;

  for (const pos of pagePositions) {
    if (pos.top + pos.height > scrollTop) {
      if (pos.page !== currentPage) {
        store.state.currentPage = pos.page; // Direct mutation — skip subscriber
        updateStatusBar(pos.page);
      }
      return;
    }
  }
}

function updateStatusBar(page) {
  const state = store.getState();
  const slider = document.getElementById('page-slider');
  if (slider) slider.value = page;
  const pageInfo = document.getElementById('page-info');
  if (pageInfo) pageInfo.innerHTML = `Page <strong>${page}</strong> of ${state.totalPages}`;
  const pct = Math.round((page / Math.max(state.totalPages, 1)) * 100);
  const readPct = document.getElementById('read-pct');
  if (readPct) readPct.textContent = `${pct}% read`;
  const fill = document.getElementById('reading-progress-fill');
  if (fill) fill.style.width = pct + '%';
}

// ===== BOOKMARKS =====
function toggleBookmark() {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;

  const bookmarks = { ...state.bookmarks };
  if (!bookmarks[docId]) bookmarks[docId] = [];

  const idx = bookmarks[docId].indexOf(state.currentPage);
  if (idx >= 0) {
    bookmarks[docId].splice(idx, 1);
    showToast('Bookmark removed');
  } else {
    bookmarks[docId].push(state.currentPage);
    bookmarks[docId].sort((a, b) => a - b);
    showToast(`Page ${state.currentPage} bookmarked`);
  }

  store.setState({ bookmarks });
  store.persistBookmarks();

  // Update bookmark icon without full re-render
  const btn = document.getElementById('btn-bookmark');
  if (btn) {
    const isNowBookmarked = bookmarks[docId]?.includes(state.currentPage);
    btn.innerHTML = isNowBookmarked ? Icons.bookmarkFill : Icons.bookmark;
  }
}

function removeBookmark(page) {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const bookmarks = { ...state.bookmarks };
  if (bookmarks[docId]) {
    bookmarks[docId] = bookmarks[docId].filter(p => p !== page);
  }
  store.setState({ bookmarks });
  store.persistBookmarks();
  showToast('Bookmark removed');
}

// ===== THUMBNAIL UTILITIES =====
function saveThumb(docId, dataUrl) {
  try { localStorage.setItem('pdfr-thumb-' + docId, dataUrl); } catch(_) {}
}

function getThumb(docId) {
  return localStorage.getItem('pdfr-thumb-' + docId) || null;
}

async function captureLibraryThumb(docId, pdfDoc) {
  if (!pdfDoc || getThumb(docId)) return; // Already captured
  try {
    const page = await pdfDoc.getPage(1);
    const vp = page.getViewport({ scale: 1 });
    const scale = 200 / vp.width;
    const viewport = page.getViewport({ scale });
    const cvs = document.createElement('canvas');
    cvs.width = Math.round(viewport.width);
    cvs.height = Math.round(viewport.height);
    await page.render({ canvasContext: cvs.getContext('2d'), viewport }).promise;
    const dataUrl = cvs.toDataURL('image/jpeg', 0.65);
    saveThumb(docId, dataUrl);
    // Update any currently visible library card thumbnail
    const card = document.querySelector(`[data-doc-id="${docId}"] .doc-card-thumb`);
    if (card) {
      const placeholder = card.querySelector('.thumb-placeholder');
      if (placeholder) {
        placeholder.outerHTML = `<img class="doc-thumb-img" src="${dataUrl}" alt="Page preview">`;
      }
    }
  } catch(_) {}
}

// ===== ANNOTATIONS =====
function toggleAnnotationMode(mode) {
  const current = store.getState().annotationMode;
  const newMode = current === mode ? null : mode;
  store.setState({ annotationMode: newMode });
  // Toggle note-mode cursor
  const canvas = document.querySelector('.reading-canvas');
  if (canvas) canvas.classList.toggle('note-mode', newMode === 'note');
}

function addAnnotation(type, page, data) {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const annotations = { ...state.annotations };
  if (!annotations[docId]) annotations[docId] = [];
  annotations[docId].push({
    id: generateId(), type, page,
    color: state.highlightColor,
    created: Date.now(),
    ...data
  });
  store.setState({ annotations, undoStack: [] }); // Clear redo on new annotation
  store.persistAnnotations();
}

function undoAnnotation() {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const annotations = { ...state.annotations };
  const undoStack = [...(state.undoStack || [])];
  if (annotations[docId]?.length > 0) {
    const removed = annotations[docId].pop();
    undoStack.push(removed);
    store.setState({ annotations, undoStack });
    store.persistAnnotations();
    showToast('Annotation undone');
    // Refresh highlights on the affected page
    const wrapper = document.getElementById(`page-wrap-${removed.page}`);
    if (wrapper) {
      renderHighlightsForPage(removed.page, wrapper);
      renderFreehandForPage(removed.page, wrapper);
    }
  }
}

function redoAnnotation() {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const undoStack = [...(state.undoStack || [])];
  if (undoStack.length === 0) return;
  const annotations = { ...state.annotations };
  if (!annotations[docId]) annotations[docId] = [];
  const restored = undoStack.pop();
  annotations[docId].push(restored);
  store.setState({ annotations, undoStack });
  store.persistAnnotations();
  showToast('Annotation restored');
  const wrapper = document.getElementById(`page-wrap-${restored.page}`);
  if (wrapper) {
    renderHighlightsForPage(restored.page, wrapper);
    renderFreehandForPage(restored.page, wrapper);
  }
}

// ===== READING PROGRESS =====
function saveReadingProgress() {
  const state = store.getState();
  if (!state.currentDoc) return;
  const progress = state.currentPage / Math.max(state.totalPages, 1);
  const docs = state.documents.map(d =>
    d.id === state.currentDoc.id
      ? { ...d, lastPage: state.currentPage, progress, lastOpened: Date.now() }
      : d
  );
  store.setState({
    documents: docs,
    currentDoc: { ...state.currentDoc, lastPage: state.currentPage, progress }
  });
  store.persistDocs();
}

// ===== KEYBOARD SHORTCUTS =====
function handleKeyboard(e) {
  const state = store.getState();
  if (state.view !== 'reader') return;
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

  switch (e.key) {
    case 'ArrowRight': case 'ArrowDown':
      if (!state.continuousScroll) { e.preventDefault(); goToPage(state.currentPage + 1); }
      break;
    case 'ArrowLeft': case 'ArrowUp':
      if (!state.continuousScroll) { e.preventDefault(); goToPage(state.currentPage - 1); }
      break;
    case 'Home': e.preventDefault(); goToPage(1); break;
    case 'End': e.preventDefault(); goToPage(state.totalPages); break;
    case 'f':
      if (e.ctrlKey || e.metaKey) { e.preventDefault(); store.setState({ searchOpen: true }); }
      break;
    case 'b':
      if (e.ctrlKey || e.metaKey) { e.preventDefault(); toggleBookmark(); }
      break;
    case 'Escape':
      if (state.searchOpen) store.setState({ searchOpen: false });
      else if (state.settingsOpen) store.setState({ settingsOpen: false });
      else if (state.focusMode) store.setState({ focusMode: false });
      else if (state.annotationMode) store.setState({ annotationMode: null });
      break;
    case '+': case '=':
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        nudgeZoom(1, { renderMode: 'immediate' });
      }
      break;
    case '-':
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        nudgeZoom(-1, { renderMode: 'immediate' });
      }
      break;
    case '0':
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        setZoomLevel(1, { renderMode: 'immediate' });
      }
      break;
  }
}

// ===== SMART STATE SUBSCRIBER =====
store.subscribe((state, prev) => {
  // Full re-render only on view transitions
  if (state.view !== currentView) {
    currentView = state.view;
    renderApp();
    return;
  }

  if (state.view === 'library') {
    // Library: only full re-render for structural changes
    if (state.documents !== prev.documents || state.isDragging !== prev.isDragging) {
      renderApp();
      return;
    }
    // Settings modal toggle
    if (state.settingsOpen !== prev.settingsOpen) {
      renderApp();
      return;
    }
    // Toast
    if (state.toast !== prev.toast) {
      const existingToast = document.querySelector('.toast');
      if (existingToast) existingToast.remove();
      if (state.toast) {
        const t = document.createElement('div');
        t.className = 'toast';
        t.setAttribute('role', 'status');
        t.textContent = state.toast;
        document.querySelector('.app-shell')?.appendChild(t);
      }
    }
    return;
  }

  // Reader: targeted updates
  if (state.view === 'reader') {
    // Loading state changed — swap spinner ↔ page container
    if (state.loading !== prev.loading) {
      renderApp();
      return;
    }

    // Loading progress — update the bar width directly
    if (state.loadProgress !== prev.loadProgress && state.loading) {
      const bar = document.querySelector('.load-progress-bar');
      if (bar) bar.style.width = (state.loadProgress || 5) + '%';
      return;
    }

    // Settings / search modals — full re-render
    if (state.settingsOpen !== prev.settingsOpen ||
        state.searchOpen !== prev.searchOpen ||
        state.sidePanel !== prev.sidePanel ||
        state.sidePanelTab !== prev.sidePanelTab ||
        state.showRuler !== prev.showRuler) {
      renderApp();
      return;
    }

    // Focus mode toggle
    if (state.focusMode !== prev.focusMode) {
      const shell = document.querySelector('.app-shell');
      if (shell) shell.classList.toggle('focus-mode', state.focusMode);
    }

    // Zoom display
    if (state.zoom !== prev.zoom) {
      syncZoomIndicators(state.zoom);
    }

    // Annotation mode or color changed — update anno-bar directly
    if (state.annotationMode !== prev.annotationMode || state.highlightColor !== prev.highlightColor) {
      updateAnnoBar(state);
      // reading-canvas note-mode class
      const canvas = document.querySelector('.reading-canvas');
      if (canvas) canvas.classList.toggle('note-mode', state.annotationMode === 'note');
    }

    // Reading progress bar
    if (state.currentPage !== prev.currentPage || state.totalPages !== prev.totalPages) {
      const fill = document.getElementById('reading-progress-fill');
      if (fill) fill.style.width = Math.round((state.currentPage / Math.max(state.totalPages, 1)) * 100) + '%';
    }

    // Toast
    if (state.toast !== prev.toast) {
      const existingToast = document.querySelector('.toast');
      if (existingToast) existingToast.remove();
      if (state.toast) {
        const t = document.createElement('div');
        t.className = 'toast';
        t.setAttribute('role', 'status');
        t.textContent = state.toast;
        document.querySelector('.app-shell')?.appendChild(t);
      }
    }
  }
});

// ===== INITIALIZE =====
setupTextSelectionHandler();
setupTapToNote();
setupLongPressHandler();

window.addEventListener('pdf-loaded', () => {
  renderVisiblePages(true);
  if (store.getState().sidePanel && store.getState().sidePanelTab === 'thumbnails') {
    setTimeout(renderThumbnails, 300);
  }

});

let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    if (store.getState().view === 'reader' && store.getState().pdfDoc) {
      renderVisiblePages(true);
    }
  }, 250);
});

// Service Worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').then(reg => {
      reg.addEventListener('updatefound', () => {
        const newWorker = reg.installing;
        newWorker?.addEventListener('statechange', () => {
          if (newWorker.state === 'activated') {
            showToast('App updated! Refresh for the latest version.');
          }
        });
      });
    }).catch((err) => {
      console.warn('Service worker registration failed:', err);
    });
  });
}

// Capacitor back button
if (window.Capacitor?.Plugins?.App) {
  window.Capacitor.Plugins.App.addListener('backButton', () => {
    const state = store.getState();
    if (state.settingsOpen) store.setState({ settingsOpen: false });
    else if (state.searchOpen) store.setState({ searchOpen: false });
    else if (state.view === 'reader') {
      saveReadingProgress();
      store.setState({ view: 'library', sidePanel: false, searchOpen: false, focusMode: false });
    } else {
      window.Capacitor.Plugins.App.exitApp();
    }
  });
}

// Initial render
renderApp();
</script>
</body>
</html>

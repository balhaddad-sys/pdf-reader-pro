<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#f8f9fb">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com 'unsafe-inline'; worker-src 'self' blob:; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: blob:; connect-src 'self' https:; frame-src 'none'; object-src 'none'; base-uri 'self'; form-action 'self'">
<meta name="description" content="A fast, private, offline-capable PDF reader. Highlight, annotate, bookmark, and read PDFs beautifully on any device.">
<meta property="og:title" content="PDF Reader Pro">
<meta property="og:description" content="A fast, private, offline-capable PDF reader with highlights, annotations, and bookmarks.">
<meta property="og:type" content="website">
<meta property="og:image" content="./icons/icon-512.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PDF Reader Pro">
<meta name="twitter:description" content="A fast, private, offline-capable PDF reader with highlights, annotations, and bookmarks.">
<title>PDF Reader Pro</title>
<link rel="icon" type="image/png" sizes="96x96" href="./icons/icon-96.png">
<link rel="apple-touch-icon" href="./icons/icon-192.png">
<link rel="manifest" href="manifest.json">
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
<link rel="dns-prefetch" href="https://fonts.googleapis.com">
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" integrity="sha384-/1qUCSGwTur9vjf/z9lmu/eCUYbpOTgSjmpbMQZ1/CtX2v/WcAIKqRv+U1DUCG6e" crossorigin="anonymous"></script>
<link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;0,8..60,700;1,8..60,400&family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }

:root {
  --bg-primary: #f8f9fb;
  --bg-secondary: #eff1f5;
  --bg-tertiary: #e4e7ed;
  --bg-canvas: #ffffff;
  --bg-glass: rgba(248,249,251,0.82);
  --text-primary: #0f172a;
  --text-secondary: #475569;
  --text-tertiary: #94a3b8;
  --accent: #3b82f6;
  --accent-soft: rgba(59,130,246,0.08);
  --accent-hover: #2563eb;
  --accent-glow: rgba(59,130,246,0.2);
  --danger: #ef4444;
  --danger-soft: rgba(239,68,68,0.08);
  --success: #22c55e;
  --border: rgba(0,0,0,0.06);
  --border-strong: rgba(0,0,0,0.1);
  --shadow-xs: 0 1px 2px rgba(0,0,0,0.04);
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.06), 0 1px 2px rgba(0,0,0,0.04);
  --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.07), 0 2px 4px -2px rgba(0,0,0,0.05);
  --shadow-lg: 0 10px 25px -5px rgba(0,0,0,0.08), 0 8px 10px -6px rgba(0,0,0,0.04);
  --shadow-xl: 0 20px 50px -12px rgba(0,0,0,0.12);
  --shadow-page: 0 1px 3px rgba(0,0,0,0.06), 0 4px 16px rgba(0,0,0,0.06);
  --radius-sm: 8px;
  --radius-md: 12px;
  --radius-lg: 16px;
  --radius-xl: 24px;
  --radius-full: 9999px;
  --font-ui: 'DM Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  --font-reading: 'Source Serif 4', Georgia, 'Times New Roman', serif;
  --font-mono: 'JetBrains Mono', 'SF Mono', monospace;
  --panel-width: 280px;
  --topbar-height: 56px;
  --statusbar-height: 36px;
  --highlight-yellow: rgba(250,204,21,0.35);
  --highlight-green: rgba(74,222,128,0.30);
  --highlight-blue: rgba(96,165,250,0.30);
  --highlight-pink: rgba(244,114,182,0.30);
  --highlight-purple: rgba(168,85,247,0.30);
  --transition-fast: 120ms cubic-bezier(0.2,0,0,1);
  --transition-smooth: 250ms cubic-bezier(0.2,0,0,1);
  --transition-spring: 400ms cubic-bezier(0.34,1.56,0.64,1);
}

[data-theme="dark"] {
  --bg-primary: #0c0f1a;
  --bg-secondary: #141825;
  --bg-tertiary: #1e2436;
  --bg-canvas: #111624;
  --bg-glass: rgba(12,15,26,0.85);
  --text-primary: #e2e8f0;
  --text-secondary: #94a3b8;
  --text-tertiary: #64748b;
  --accent: #60a5fa;
  --accent-soft: rgba(96,165,250,0.12);
  --accent-hover: #93bbfd;
  --accent-glow: rgba(96,165,250,0.25);
  --border: rgba(255,255,255,0.06);
  --border-strong: rgba(255,255,255,0.1);
  --shadow-xs: 0 1px 2px rgba(0,0,0,0.3);
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.4);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.5);
  --shadow-lg: 0 10px 30px rgba(0,0,0,0.5);
  --shadow-xl: 0 20px 50px rgba(0,0,0,0.6);
  --shadow-page: 0 2px 16px rgba(0,0,0,0.5);
}

[data-theme="sepia"] {
  --bg-primary: #f5efe6;
  --bg-secondary: #ece5d8;
  --bg-tertiary: #ddd4c4;
  --bg-canvas: #faf5ec;
  --bg-glass: rgba(245,239,230,0.85);
  --text-primary: #3c2f20;
  --text-secondary: #6d5d4b;
  --text-tertiary: #9a8c7b;
  --accent: #c2731e;
  --accent-soft: rgba(194,115,30,0.1);
  --accent-hover: #d4842a;
  --accent-glow: rgba(194,115,30,0.2);
  --border: rgba(61,47,32,0.08);
  --border-strong: rgba(61,47,32,0.14);
  --shadow-page: 0 2px 12px rgba(61,47,32,0.08);
}

html, body { 
  height: 100%; 
  overflow: hidden; 
  font-family: var(--font-ui);
  background: var(--bg-primary);
  color: var(--text-primary);
  -webkit-font-smoothing: antialiased;
  -webkit-tap-highlight-color: transparent;
}

#root { height: 100%; }

::selection { background: var(--accent-soft); color: var(--accent); }

::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--text-tertiary); border-radius: 3px; opacity: 0.5; }
::-webkit-scrollbar-thumb:hover { background: var(--text-secondary); }

input, button, textarea { font-family: inherit; }

button { 
  cursor: pointer; 
  border: none; 
  background: none; 
  color: inherit;
  outline: none;
}

button:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
  border-radius: var(--radius-sm);
}

/* ===== ANIMATIONS ===== */
@keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
@keyframes slideUp { from { opacity:0; transform:translateY(16px); } to { opacity:1; transform:translateY(0); } }
@keyframes slideRight { from { opacity:0; transform:translateX(-16px); } to { opacity:1; transform:translateX(0); } }
@keyframes scaleIn { from { opacity:0; transform:scale(0.96); } to { opacity:1; transform:scale(1); } }
@keyframes slideInBottom { from { opacity:0; transform:translateY(100%); } to { opacity:1; transform:translateY(0); } }
@keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:0.5;} }
@keyframes spin { to { transform: rotate(360deg); } }
@keyframes shimmer { 0%{background-position:-200% 0;} 100%{background-position:200% 0;} }
@keyframes glow { 0%,100%{box-shadow:0 0 0 0 var(--accent-glow);} 50%{box-shadow:0 0 0 8px transparent;} }

.animate-fade { animation: fadeIn 0.25s cubic-bezier(0.2,0,0,1); }
.animate-slide-up { animation: slideUp 0.35s cubic-bezier(0.2,0,0,1); }
.animate-scale { animation: scaleIn 0.2s cubic-bezier(0.2,0,0,1); }

/* ===== APP SHELL ===== */
.app-shell {
  height: 100%;
  display: flex;
  flex-direction: column;
  background: var(--bg-primary);
  position: relative;
  overflow: hidden;
}

/* ===== LIBRARY ===== */
.library {
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.library-header {
  padding: 24px 24px 0;
  flex-shrink: 0;
}

.library-brand {
  display: flex;
  align-items: center;
  gap: 14px;
  margin-bottom: 28px;
}

.library-logo {
  width: 44px;
  height: 44px;
  background: linear-gradient(135deg, #3b82f6, #8b5cf6);
  border-radius: var(--radius-md);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 800;
  font-size: 20px;
  letter-spacing: -1px;
  box-shadow: 0 4px 12px rgba(59,130,246,0.3), 0 0 0 1px rgba(255,255,255,0.1) inset;
}

.library-title {
  font-size: 24px;
  font-weight: 800;
  letter-spacing: -0.6px;
  color: var(--text-primary);
  line-height: 1.1;
}

.library-subtitle {
  font-size: 12px;
  color: var(--text-tertiary);
  font-weight: 500;
  letter-spacing: 0.3px;
  margin-top: 2px;
}

.library-actions {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.lib-btn {
  padding: 12px 20px;
  border-radius: var(--radius-md);
  font-size: 14px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  transition: all var(--transition-fast);
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

.lib-btn-primary {
  flex: 1;
  background: var(--accent);
  color: white;
  box-shadow: 0 2px 8px var(--accent-glow), 0 1px 2px rgba(0,0,0,0.06);
}

.lib-btn-primary:hover { background: var(--accent-hover); transform: translateY(-1px); box-shadow: 0 4px 12px var(--accent-glow); }
.lib-btn-primary:active { background: var(--accent-hover); transform: scale(0.97); box-shadow: none; }

.lib-btn-secondary {
  background: var(--bg-secondary);
  color: var(--text-secondary);
  border: 1px solid var(--border);
  padding: 12px;
}

.lib-btn-secondary:hover { background: var(--bg-tertiary); color: var(--text-primary); }
.lib-btn-secondary:active { background: var(--bg-tertiary); transform: scale(0.95); }

.library-search {
  position: relative;
  margin-bottom: 16px;
}

.library-search input {
  width: 100%;
  padding: 11px 16px 11px 42px;
  background: var(--bg-secondary);
  border: 1.5px solid var(--border);
  border-radius: var(--radius-full);
  font-size: 14px;
  color: var(--text-primary);
  transition: all var(--transition-fast);
}

.library-search input:focus {
  border-color: var(--accent);
  background: var(--bg-canvas);
  box-shadow: 0 0 0 3px var(--accent-soft);
  outline: none;
}

.library-search input::placeholder { color: var(--text-tertiary); }

.library-search svg {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--text-tertiary);
}

.library-tabs {
  display: flex;
  gap: 4px;
  padding: 4px;
  background: var(--bg-secondary);
  border-radius: var(--radius-md);
  margin-bottom: 16px;
}

.lib-tab {
  flex: 1;
  padding: 8px 12px;
  font-size: 13px;
  font-weight: 500;
  border-radius: var(--radius-sm);
  color: var(--text-tertiary);
  transition: all var(--transition-fast);
}

.lib-tab.active {
  background: var(--bg-canvas);
  color: var(--text-primary);
  box-shadow: var(--shadow-sm);
}

.library-content {
  flex: 1;
  overflow-y: auto;
  padding: 0 24px 24px;
}

.library-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
  gap: 16px;
}

.doc-card {
  background: var(--bg-canvas);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  overflow: hidden;
  cursor: pointer;
  transition: all var(--transition-smooth);
  animation: slideUp 0.4s cubic-bezier(0.2,0,0,1) both;
  position: relative;
}

.doc-card:hover {
  transform: translateY(-6px);
  box-shadow: var(--shadow-xl);
  border-color: rgba(59,130,246,0.3);
}

.doc-card:active {
  transform: translateY(-2px) scale(0.99);
  box-shadow: var(--shadow-md);
}

.doc-card-thumb {
  height: 180px;
  background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
}

.doc-card-thumb canvas {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
}

.doc-card-thumb .thumb-placeholder {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  color: var(--text-tertiary);
}

.doc-card-thumb .thumb-placeholder svg { opacity: 0.4; }

.doc-card-progress {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: var(--border);
}

.doc-card-progress-bar {
  height: 100%;
  background: var(--accent);
  border-radius: 0 2px 2px 0;
  transition: width 0.5s ease;
}

.doc-card-info {
  padding: 14px;
}

.doc-card-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-primary);
  line-height: 1.35;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  margin-bottom: 6px;
  letter-spacing: -0.1px;
}

.doc-card-meta {
  font-size: 11px;
  color: var(--text-tertiary);
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: 500;
}

/* Empty state */
.library-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 80px 24px;
  text-align: center;
  animation: slideUp 0.5s cubic-bezier(0.2,0,0,1);
}

.library-empty-icon {
  width: 88px;
  height: 88px;
  background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
  border-radius: var(--radius-xl);
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 24px;
  color: var(--text-tertiary);
  box-shadow: var(--shadow-sm);
}

.library-empty h3 {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 8px;
  letter-spacing: -0.3px;
}

.library-empty p {
  font-size: 14px;
  color: var(--text-tertiary);
  max-width: 300px;
  line-height: 1.6;
}

/* Drop zone */
.drop-zone-overlay {
  position: fixed;
  inset: 0;
  background: rgba(45,91,227,0.08);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  animation: fadeIn 0.2s ease;
}

.drop-zone-box {
  padding: 52px 72px;
  border: 2px dashed var(--accent);
  border-radius: var(--radius-xl);
  background: var(--bg-canvas);
  text-align: center;
  box-shadow: var(--shadow-xl);
  animation: scaleIn 0.25s cubic-bezier(0.34,1.56,0.64,1);
}

.drop-zone-box svg { color: var(--accent); margin-bottom: 16px; }
.drop-zone-box h3 { font-size: 20px; font-weight: 700; margin-bottom: 6px; letter-spacing: -0.3px; }
.drop-zone-box p { font-size: 14px; color: var(--text-tertiary); }

/* ===== READER ===== */
.reader-shell {
  height: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Top Bar */
.reader-topbar {
  height: var(--topbar-height);
  background: var(--bg-glass);
  backdrop-filter: blur(16px) saturate(180%);
  -webkit-backdrop-filter: blur(16px) saturate(180%);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 8px;
  gap: 2px;
  flex-shrink: 0;
  z-index: 100;
  transition: opacity var(--transition-smooth), transform var(--transition-smooth);
}

.reader-topbar.hidden {
  opacity: 0;
  pointer-events: none;
  transform: translateY(-100%);
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}

.topbar-btn {
  width: 40px;
  height: 40px;
  min-width: 40px;
  min-height: 40px;
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  transition: all var(--transition-fast);
  flex-shrink: 0;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  position: relative;
}

.topbar-btn:hover { background: var(--bg-secondary); color: var(--text-primary); }
.topbar-btn:active { background: var(--bg-tertiary); color: var(--text-primary); transform: scale(0.9); }
.topbar-btn.active { background: var(--accent-soft); color: var(--accent); }
.topbar-btn.active:active { background: var(--accent-soft); transform: scale(0.9); }

.topbar-sep {
  width: 1px;
  height: 20px;
  background: var(--border-strong);
  margin: 0 4px;
  flex-shrink: 0;
}

.topbar-title {
  flex: 1;
  min-width: 0;
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: center;
  letter-spacing: -0.2px;
  padding: 0 4px;
}

/* Reader Body */
.reader-body {
  flex: 1;
  display: flex;
  overflow: hidden;
  position: relative;
}

/* Side Panel */
.side-panel {
  width: var(--panel-width);
  background: var(--bg-primary);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  flex-shrink: 0;
  animation: slideRight 0.25s cubic-bezier(0.2,0,0,1);
}

.side-panel-tabs {
  display: flex;
  border-bottom: 1px solid var(--border);
  padding: 8px 8px 0;
  gap: 2px;
}

.sp-tab {
  padding: 8px 12px;
  font-size: 12px;
  font-weight: 600;
  color: var(--text-tertiary);
  border-bottom: 2px solid transparent;
  transition: all var(--transition-fast);
  white-space: nowrap;
}

.sp-tab:hover { color: var(--text-secondary); }
.sp-tab:active { transform: scale(0.95); }
.sp-tab.active { color: var(--accent); border-bottom-color: var(--accent); }

.side-panel-content {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
}

/* Thumbnails */
.thumb-grid {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.thumb-item {
  background: var(--bg-canvas);
  border: 2px solid var(--border);
  border-radius: var(--radius-md);
  padding: 4px;
  cursor: pointer;
  transition: all var(--transition-fast);
  display: flex;
  align-items: center;
  gap: 8px;
}

.thumb-item:hover { border-color: var(--accent); }
.thumb-item.active { border-color: var(--accent); background: var(--accent-soft); }

.thumb-item canvas {
  width: 60px;
  height: 80px;
  object-fit: contain;
  border-radius: 4px;
  flex-shrink: 0;
}

.thumb-label {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
}

/* Outline */
.outline-item {
  padding: 8px 10px;
  font-size: 13px;
  color: var(--text-secondary);
  cursor: pointer;
  border-radius: var(--radius-sm);
  transition: all var(--transition-fast);
  border-left: 2px solid transparent;
}

.outline-item:hover { background: var(--bg-secondary); color: var(--text-primary); }
.outline-item.active { border-left-color: var(--accent); color: var(--accent); background: var(--accent-soft); }

.outline-item-l1 { padding-left: 10px; font-weight: 600; }
.outline-item-l2 { padding-left: 24px; }
.outline-item-l3 { padding-left: 38px; font-size: 12px; }

/* Bookmarks */
.bookmark-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.bookmark-item:hover { background: var(--bg-secondary); }

.bookmark-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--accent);
  flex-shrink: 0;
}

.bookmark-info {
  flex: 1;
  min-width: 0;
}

.bookmark-page {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-primary);
}

.bookmark-label {
  font-size: 11px;
  color: var(--text-tertiary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.bookmark-remove {
  opacity: 0;
  transition: opacity var(--transition-fast);
}

.bookmark-item:hover .bookmark-remove { opacity: 1; }

/* Annotations Panel */
.annotation-item {
  padding: 10px;
  border-radius: var(--radius-md);
  margin-bottom: 6px;
  cursor: pointer;
  transition: all var(--transition-fast);
  border-left: 3px solid;
}

.annotation-item:hover { background: var(--bg-secondary); }

.annotation-text {
  font-size: 13px;
  color: var(--text-primary);
  line-height: 1.4;
  font-family: var(--font-reading);
  margin-bottom: 4px;
}

.annotation-meta {
  font-size: 11px;
  color: var(--text-tertiary);
}

/* Reading Canvas */
.reading-canvas {
  flex: 1;
  overflow: auto;
  background: var(--bg-secondary);
  background-image: radial-gradient(circle at 1px 1px, var(--border) 1px, transparent 0);
  background-size: 24px 24px;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  scroll-behavior: smooth;
}

.page-container {
  padding: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  min-height: 100%;
  flex-shrink: 0;
  width: 100%;
}

.page-wrapper {
  position: relative;
  box-shadow: var(--shadow-page), 0 0 0 1px rgba(0,0,0,0.03);
  border-radius: 4px;
  overflow: hidden;
  background: white;
  transition: box-shadow var(--transition-smooth);
  flex-shrink: 0;
  max-width: 100%;
}

.page-wrapper canvas {
  display: block;
  max-width: 100%;
  height: auto;
}

[data-theme="dark"] .page-wrapper { background: #faf9f7; }
[data-theme="sepia"] .page-wrapper { background: #fefcf7; }

.page-number-label {
  text-align: center;
  font-size: 11px;
  color: var(--text-tertiary);
  padding: 4px 0 8px;
  font-variant-numeric: tabular-nums;
}

/* Text selection layer */
.text-layer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  overflow: hidden;
  line-height: 1;
  z-index: 2;
  -webkit-touch-callout: none;
  -webkit-user-select: text;
  user-select: text;
}

.text-layer span {
  position: absolute;
  white-space: pre;
  transform-origin: 0% 0%;
  color: transparent;
  padding: 1px 0;
}

.text-layer span::selection {
  background: rgba(59,130,246,0.3);
  color: transparent;
}

/* Highlight overlays */
.highlight-overlay {
  position: absolute;
  pointer-events: none;
  border-radius: 2px;
}

/* Note pins — sticky-note icons placed on the page */
.note-pin {
  position: absolute;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  pointer-events: auto;
  z-index: 10;
  transition: transform 0.15s, box-shadow 0.15s;
  box-shadow: var(--shadow-sm);
  border: 2px solid rgba(255,255,255,0.9);
}
.note-pin:hover { transform: scale(1.2); box-shadow: var(--shadow-md); }
.note-pin svg { width: 14px; height: 14px; color: #fff; flex-shrink: 0; }

/* Note popover — shown when clicking a pin */
.note-popover {
  position: absolute;
  z-index: 100;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-lg);
  padding: 12px;
  width: 240px;
  max-height: 200px;
  overflow-y: auto;
  font-family: var(--font-ui);
  font-size: 13px;
  color: var(--text-primary);
  pointer-events: auto;
}
.note-popover-text { margin-bottom: 8px; white-space: pre-wrap; word-break: break-word; line-height: 1.5; }
.note-popover-quote { font-size: 11px; color: var(--text-tertiary); font-style: italic; border-left: 2px solid var(--border-strong); padding-left: 8px; margin-bottom: 8px; }
.note-popover-actions { display: flex; gap: 8px; justify-content: flex-end; }
.note-popover-actions button { font-size: 11px; padding: 4px 10px; border-radius: var(--radius-sm); cursor: pointer; font-family: var(--font-ui); font-weight: 500; }
.note-popover .btn-delete { background: var(--danger-soft); color: var(--danger); }
.note-popover .btn-delete:hover { background: var(--danger); color: white; }
.note-popover .btn-close { background: var(--bg-secondary); color: var(--text-secondary); }

/* Note mode cursor */
.reading-canvas.note-mode { cursor: crosshair; }
.reading-canvas.note-mode .page-wrapper { cursor: crosshair; }

/* Long-press context toolbar */
.selection-toolbar {
  position: fixed;
  z-index: 9998;
  display: flex;
  gap: 2px;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-lg);
  padding: 4px;
  animation: scaleIn 0.15s cubic-bezier(0.2,0,0,1);
}
.selection-toolbar button {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 8px 12px;
  border-radius: var(--radius-sm);
  font-family: var(--font-ui);
  font-size: 12px;
  font-weight: 500;
  color: var(--text-primary);
  white-space: nowrap;
  cursor: pointer;
  min-height: 44px;
  transition: background 0.15s;
}
.selection-toolbar button:hover { background: var(--bg-secondary); }
.selection-toolbar button:active { background: var(--bg-tertiary); }
.selection-toolbar button svg { flex-shrink: 0; }

/* Status Bar */
.reader-statusbar {
  height: var(--statusbar-height);
  background: var(--bg-glass);
  backdrop-filter: blur(12px) saturate(180%);
  -webkit-backdrop-filter: blur(12px) saturate(180%);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  font-size: 11px;
  font-weight: 500;
  color: var(--text-tertiary);
  font-variant-numeric: tabular-nums;
  flex-shrink: 0;
  z-index: 100;
  transition: opacity var(--transition-smooth);
}

.reader-statusbar.hidden { opacity: 0; pointer-events: none; }

.status-left, .status-right { display: flex; align-items: center; gap: 12px; }

.status-divider {
  width: 1px;
  height: 12px;
  background: var(--border-strong);
}

/* Page Slider */
.page-slider-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
}

.page-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 120px;
  height: 4px;
  background: var(--bg-tertiary);
  border-radius: var(--radius-full);
  outline: none;
}

.page-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: var(--radius-full);
  background: var(--accent);
  cursor: pointer;
  box-shadow: 0 1px 4px var(--accent-glow), 0 1px 2px rgba(0,0,0,0.1);
  transition: transform 0.15s ease;
}

.page-slider::-webkit-slider-thumb:hover {
  transform: scale(1.15);
}

.page-slider:active::-webkit-slider-thumb {
  transform: scale(1.2);
}

/* ===== SEARCH OVERLAY ===== */
.search-overlay {
  position: absolute;
  top: calc(var(--topbar-height) + 4px);
  right: 12px;
  width: 340px;
  max-height: 420px;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-xl);
  z-index: 200;
  display: flex;
  flex-direction: column;
  animation: scaleIn 0.2s cubic-bezier(0.2,0,0,1);
  overflow: hidden;
}

.search-input-wrap {
  padding: 12px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 8px;
}

.search-input-wrap input {
  flex: 1;
  border: none;
  background: transparent;
  font-size: 14px;
  color: var(--text-primary);
  outline: none;
}

.search-input-wrap input::placeholder { color: var(--text-tertiary); }

.search-results {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.search-result-item {
  padding: 8px 10px;
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: background var(--transition-fast);
}

.search-result-item:hover { background: var(--bg-secondary); }
.search-result-item.active { background: var(--accent-soft); }

.search-result-page {
  font-size: 11px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 2px;
}

.search-result-context {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.4;
}

.search-result-context mark {
  background: var(--highlight-yellow);
  color: inherit;
  border-radius: 2px;
  padding: 0 2px;
}

.search-count {
  padding: 8px 12px;
  font-size: 11px;
  color: var(--text-tertiary);
  border-top: 1px solid var(--border);
}

/* ===== ANNOTATION FAB & MENU ===== */
.anno-fab {
  position: fixed;
  bottom: 28px;
  right: 24px;
  width: 56px;
  height: 56px;
  border-radius: var(--radius-full);
  background: linear-gradient(135deg, var(--accent), #6366f1);
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 14px var(--accent-glow), 0 2px 6px rgba(0,0,0,0.1);
  z-index: 300;
  transition: all var(--transition-fast);
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}
.anno-fab:hover { transform: scale(1.06); box-shadow: 0 6px 20px var(--accent-glow), 0 3px 10px rgba(0,0,0,0.1); }
.anno-fab:active { transform: scale(0.92); box-shadow: 0 2px 6px var(--accent-glow); }
.anno-fab.active { background: var(--text-primary); box-shadow: var(--shadow-lg); }

.anno-menu {
  position: fixed;
  bottom: 96px;
  right: 24px;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-lg);
  padding: 6px;
  display: flex;
  flex-direction: column;
  gap: 2px;
  box-shadow: var(--shadow-xl);
  z-index: 300;
  animation: slideUp 0.2s cubic-bezier(0.2,0,0,1);
  min-width: 52px;
}

.anno-btn {
  width: 48px;
  height: 46px;
  border-radius: var(--radius-sm);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-secondary);
  transition: all var(--transition-fast);
  position: relative;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

.anno-btn:hover { background: var(--bg-secondary); color: var(--text-primary); }
.anno-btn:active { background: var(--bg-tertiary); transform: scale(0.92); }
.anno-btn.active { background: var(--accent-soft); color: var(--accent); }
.anno-btn.active:active { transform: scale(0.92); }

.anno-color-row {
  display: flex;
  gap: 4px;
  padding: 6px 4px;
  justify-content: center;
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  margin: 2px 0;
}

.color-dot {
  width: 24px;
  height: 24px;
  border-radius: var(--radius-full);
  border: 2.5px solid transparent;
  transition: all var(--transition-fast);
  cursor: pointer;
}

.color-dot:hover { transform: scale(1.15); }
.color-dot:active { transform: scale(0.88); }
.color-dot.active { border-color: var(--text-primary); box-shadow: 0 0 0 2px var(--bg-canvas); }

.anno-label {
  font-size: 10px;
  text-align: center;
  color: var(--text-tertiary);
  margin-top: -2px;
}

/* ===== CONTEXT MENU ===== */
.context-menu {
  position: fixed;
  background: var(--bg-canvas);
  border: 1px solid var(--border-strong);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-lg);
  z-index: 400;
  min-width: 180px;
  padding: 6px;
  animation: scaleIn 0.15s ease;
}

.ctx-item {
  padding: 8px 12px;
  font-size: 13px;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: 10px;
  border-radius: var(--radius-sm);
  transition: all var(--transition-fast);
  width: 100%;
  text-align: left;
}

.ctx-item:hover { background: var(--bg-secondary); color: var(--text-primary); }
.ctx-item svg { flex-shrink: 0; }

/* ===== SETTINGS MODAL ===== */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  z-index: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  animation: fadeIn 0.15s cubic-bezier(0.2,0,0,1);
}

.modal-content {
  width: 90%;
  max-width: 440px;
  max-height: 80vh;
  background: var(--bg-canvas);
  border-radius: var(--radius-xl);
  box-shadow: var(--shadow-xl);
  overflow: hidden;
  animation: scaleIn 0.25s cubic-bezier(0.34,1.56,0.64,1);
  display: flex;
  flex-direction: column;
  border: 1px solid var(--border);
}

.modal-header {
  padding: 20px 24px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.modal-header h2 {
  font-size: 18px;
  font-weight: 700;
  letter-spacing: -0.3px;
}

.modal-body {
  padding: 20px 24px;
  overflow-y: auto;
  flex: 1;
}

.setting-group {
  margin-bottom: 24px;
}

.setting-group-title {
  font-size: 11px;
  font-weight: 700;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 12px;
}

.setting-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 0;
}

.setting-label {
  font-size: 14px;
  color: var(--text-primary);
}

.setting-desc {
  font-size: 12px;
  color: var(--text-tertiary);
}

/* Toggle Switch */
.toggle {
  width: 44px;
  height: 24px;
  background: var(--bg-tertiary);
  border-radius: 12px;
  position: relative;
  cursor: pointer;
  transition: background var(--transition-fast);
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

.toggle.active { background: var(--accent); }

.toggle::after {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 20px;
  height: 20px;
  background: white;
  border-radius: 50%;
  transition: transform var(--transition-fast);
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.toggle.active::after { transform: translateX(20px); }

/* Theme Picker */
.theme-picker {
  display: flex;
  gap: 10px;
}

.theme-option {
  flex: 1;
  height: 52px;
  border-radius: var(--radius-md);
  border: 2px solid var(--border);
  cursor: pointer;
  transition: all var(--transition-fast);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: 600;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

.theme-option:hover { border-color: var(--text-tertiary); }
.theme-option:active { transform: scale(0.95); }
.theme-option.active { border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-soft); }

.theme-light { background: #f8f9fb; color: #0f172a; }
.theme-dark { background: #0c0f1a; color: #e2e8f0; }
.theme-sepia { background: #f5efe6; color: #3c2f20; }

/* ===== FOCUS MODE ===== */
.focus-mode .reader-topbar,
.focus-mode .reader-statusbar,
.focus-mode .side-panel {
  opacity: 0;
  pointer-events: none;
}

.focus-mode .reading-canvas {
  background: var(--bg-primary);
}

.focus-mode .page-container {
  padding-top: 40px;
}

/* ===== LOADING ===== */
.loading-wrap {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 80px 40px;
  gap: 20px;
  color: var(--text-tertiary);
  font-size: 14px;
  font-weight: 500;
}

.spinner {
  width: 36px;
  height: 36px;
  border: 3px solid var(--border-strong);
  border-top-color: var(--accent);
  border-radius: var(--radius-full);
  animation: spin 0.7s linear infinite;
}

/* ===== TOAST ===== */
.toast {
  position: fixed;
  bottom: 100px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--text-primary);
  color: var(--bg-canvas);
  padding: 12px 24px;
  border-radius: var(--radius-full);
  font-size: 13px;
  font-weight: 600;
  letter-spacing: -0.1px;
  box-shadow: var(--shadow-xl);
  z-index: 600;
  animation: slideUp 0.35s cubic-bezier(0.34,1.56,0.64,1);
  pointer-events: none;
  white-space: nowrap;
}

/* ===== READING RULER ===== */
.reading-ruler {
  position: fixed;
  left: 0;
  right: 0;
  height: 2px;
  background: var(--accent);
  opacity: 0.3;
  pointer-events: none;
  z-index: 50;
  transition: top 0.1s ease;
}

/* ===== DRAWING CANVAS ===== */
.drawing-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  cursor: crosshair;
  z-index: 10;
  touch-action: none;
}

/* ===== DOC CARD DELETE ===== */
.doc-card-delete {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 30px;
  height: 30px;
  border-radius: var(--radius-full);
  background: rgba(255,255,255,0.9);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid rgba(0,0,0,0.08);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-tertiary);
  opacity: 0;
  transition: all var(--transition-fast);
  z-index: 2;
}
.doc-card:hover .doc-card-delete { opacity: 1; }
.doc-card-delete:hover { color: var(--danger); background: var(--danger-soft); border-color: var(--danger); }
.doc-card-delete:active { transform: scale(0.85); }

@media (hover: none) {
  .doc-card-delete { opacity: 0.8; }
}

.doc-card-thumb { position: relative; }

/* ===== LOADING PROGRESS ===== */
.load-progress {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  z-index: 200;
  background: var(--border);
}
.load-progress-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), #8b5cf6);
  transition: width 0.4s cubic-bezier(0.2,0,0,1);
  border-radius: 0 2px 2px 0;
  box-shadow: 0 0 8px var(--accent-glow);
}

/* ===== SIDEBAR BACKDROP (mobile) ===== */
.sidebar-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.3);
  z-index: 149;
  animation: fadeIn 0.2s ease;
}

/* ===== PAGE PLACEHOLDER ===== */
.page-placeholder {
  background: var(--bg-tertiary);
  border-radius: 2px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--text-tertiary);
  font-size: 13px;
}

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  :root {
    --topbar-height: 50px;
    --panel-width: 260px;
  }

  /* Side panel: overlay on mobile */
  .side-panel {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    z-index: 150;
    box-shadow: var(--shadow-xl);
  }

  .sidebar-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.4);
    z-index: 140;
  }

  /* Library */
  .library-header { padding: 20px 16px 0; }
  .library-brand { margin-bottom: 20px; }
  .library-title { font-size: 22px; }
  .library-grid {
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 12px;
    padding: 0 16px 16px;
  }
  .library-actions { margin-bottom: 16px; }
  .lib-btn { padding: 11px 14px; font-size: 13px; }
  .drop-zone-box { padding: 32px 24px; }
  .doc-card-thumb { height: 160px; }

  /* Reader topbar: compact layout */
  .reader-topbar {
    padding: env(safe-area-inset-top, 0px) 4px 0 4px;
    gap: 0;
    flex-wrap: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
  }
  .reader-topbar::-webkit-scrollbar { display: none; }
  .topbar-btn { min-width: 38px; min-height: 38px; width: 38px; height: 38px; }
  .topbar-sep { margin: 0 2px; height: 16px; }
  .topbar-title { font-size: 13px; min-width: 40px; padding: 0 2px; }
  #zoom-display { font-size: 11px; min-width: 32px; }

  /* Reading canvas: less padding */
  .page-container { padding: 8px; gap: 12px; }

  /* Search overlay: full width */
  .search-overlay {
    width: calc(100% - 16px);
    right: 8px;
    top: calc(var(--topbar-height) + 4px + env(safe-area-inset-top, 0px));
  }

  /* Annotation FAB: adjust for safe area */
  .anno-fab {
    bottom: calc(20px + env(safe-area-inset-bottom, 0px));
    right: 16px;
    width: 52px;
    height: 52px;
  }
  .anno-menu {
    bottom: calc(82px + env(safe-area-inset-bottom, 0px));
    right: 16px;
  }

  /* Status bar */
  .reader-statusbar {
    padding: 0 12px;
    padding-bottom: env(safe-area-inset-bottom, 0px);
    font-size: 10px;
  }
  .status-left, .status-right { gap: 6px; }
  .page-slider { width: 80px; }

  /* Modal: bottom sheet style on mobile */
  .modal-overlay { align-items: flex-end; }
  .modal-content {
    width: 100%;
    max-width: 100%;
    max-height: 85vh;
    border-radius: var(--radius-xl) var(--radius-xl) 0 0;
    animation: slideInBottom 0.3s cubic-bezier(0.2,0,0,1);
  }
}

/* Extra small screens (phones in portrait) */
@media (max-width: 420px) {
  .reader-topbar { gap: 0; padding: env(safe-area-inset-top, 0px) 2px 0 2px; }
  .topbar-btn { min-width: 36px; min-height: 36px; width: 36px; height: 36px; }
  .topbar-sep { display: none; }
  .topbar-title { font-size: 12px; }
  .page-container { padding: 4px; gap: 8px; }
  .library-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
  .page-slider { width: 60px; }
  #zoom-display { display: none; }
  .status-divider:first-of-type { display: none; }
  .page-slider-wrap { display: none; }
  .doc-card-thumb { height: 140px; }
  .library-title { font-size: 20px; }
}

/* Print */
@media print {
  .reader-topbar, .reader-statusbar, .side-panel, .anno-fab, .anno-menu { display: none !important; }
  .reading-canvas { overflow: visible !important; }
}

/* ===== ACCESSIBILITY ===== */
/* Skip-to-content link */
.skip-link {
  position: absolute;
  top: -100%;
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent);
  color: #fff;
  padding: 0.75rem 1.5rem;
  border-radius: var(--radius-md);
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 0.875rem;
  z-index: 10000;
  text-decoration: none;
  transition: top 0.2s;
}
.skip-link:focus {
  top: 1rem;
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

/* Minimum touch targets (WCAG 2.2 AA - 44x44px) */
.reader-topbar button,
.reader-statusbar button,
.anno-menu button,
.side-panel-tabs button {
  min-width: 44px;
  min-height: 44px;
}

/* Reduced motion: disable all animations and transitions */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

/* Offline indicator */
.offline-banner {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: var(--danger);
  color: #fff;
  text-align: center;
  padding: 6px 16px;
  font-family: var(--font-ui);
  font-size: 0.8125rem;
  font-weight: 500;
  z-index: 9999;
  transform: translateY(-100%);
  transition: transform 0.3s;
}
.offline-banner.visible {
  transform: translateY(0);
}
</style>
</head>
<body>
<a href="#root" class="skip-link">Skip to content</a>
<div class="offline-banner" id="offline-banner" role="alert" aria-live="assertive">You are offline. Some features may be unavailable.</div>
<div id="root" role="main"></div>
<script>
// ===== PDF Reader Pro — Full Application =====
// Production-grade PWA with IndexedDB persistence, virtualized scrolling,
// text selection, annotations, freehand drawing, and mobile optimization.

// ===== GLOBAL ERROR HANDLING =====
window.addEventListener('error', (event) => {
  console.error('[PDF Reader Pro]', event.error || event.message);
  const toast = document.querySelector('.toast');
  if (!toast) {
    const t = document.createElement('div');
    t.className = 'toast';
    t.setAttribute('role', 'alert');
    t.setAttribute('aria-live', 'assertive');
    t.textContent = 'Something went wrong. Please try again.';
    document.querySelector('.app-shell')?.appendChild(t);
    setTimeout(() => t.remove(), 3000);
  }
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('[PDF Reader Pro] Unhandled promise rejection:', event.reason);
});

// ===== OFFLINE DETECTION =====
function updateOnlineStatus() {
  const banner = document.getElementById('offline-banner');
  if (banner) {
    banner.classList.toggle('visible', !navigator.onLine);
  }
}
window.addEventListener('online', updateOnlineStatus);
window.addEventListener('offline', updateOnlineStatus);
updateOnlineStatus();

// ===== WEB VITALS MONITORING =====
(function initWebVitals() {
  if (!('PerformanceObserver' in window)) return;

  // Largest Contentful Paint
  try {
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const last = entries[entries.length - 1];
      console.info('[Web Vitals] LCP:', Math.round(last.startTime), 'ms');
    }).observe({ type: 'largest-contentful-paint', buffered: true });
  } catch (_) {}

  // Cumulative Layout Shift
  try {
    let clsScore = 0;
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) clsScore += entry.value;
      }
      console.info('[Web Vitals] CLS:', clsScore.toFixed(4));
    }).observe({ type: 'layout-shift', buffered: true });
  } catch (_) {}

  // Interaction to Next Paint
  try {
    new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        console.info('[Web Vitals] INP candidate:', Math.round(entry.duration), 'ms');
      }
    }).observe({ type: 'event', buffered: true, durationThreshold: 96 });
  } catch (_) {}
})();

// ===== STORAGE QUOTA UTILITIES =====
async function checkStorageQuota() {
  if (!navigator.storage?.estimate) return { usage: 0, quota: 0, percentUsed: 0 };
  const { usage, quota } = await navigator.storage.estimate();
  return { usage, quota, percentUsed: quota ? (usage / quota) * 100 : 0 };
}

async function warnIfStorageLow() {
  const { percentUsed } = await checkStorageQuota();
  if (percentUsed > 80) {
    showToast('Storage is almost full (' + Math.round(percentUsed) + '%). Consider removing unused PDFs.');
  }
}

const { pdfjsLib } = globalThis;
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

// ===== ICONS (inline SVG) =====
const Icons = {
  back: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 12H5"/><path d="m12 19-7-7 7-7"/></svg>`,
  search: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>`,
  bookmark: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z"/></svg>`,
  bookmarkFill: `<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z"/></svg>`,
  sidebar: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M9 3v18"/></svg>`,
  settings: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>`,
  plus: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>`,
  file: `<svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/></svg>`,
  upload: `<svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17,8 12,3 7,8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>`,
  x: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>`,
  highlight: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 11-6 6v3h9l3-3"/><path d="m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L14 4"/></svg>`,
  pen: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg>`,
  note: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8Z"/><path d="M15 3v4a2 2 0 0 0 2 2h4"/></svg>`,
  eraser: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>`,
  undo: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>`,
  redo: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3L21 13"/></svg>`,
  zoomIn: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></svg>`,
  zoomOut: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="8" x2="14" y1="11" y2="11"/></svg>`,
  focus: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>`,
  moon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>`,
  list: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" x2="21" y1="6" y2="6"/><line x1="8" x2="21" y1="12" y2="12"/><line x1="8" x2="21" y1="18" y2="18"/><line x1="3" x2="3.01" y1="6" y2="6"/><line x1="3" x2="3.01" y1="12" y2="12"/><line x1="3" x2="3.01" y1="18" y2="18"/></svg>`,
  grid: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="14" y="3" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/><rect width="7" height="7" x="14" y="14" rx="1"/></svg>`,
  trash: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>`,
  copy: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>`,
  download: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,15 17,10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>`,
  chevLeft: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>`,
  chevRight: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>`,
  ruler: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z"/><path d="m14.5 12.5 2-2"/><path d="m11.5 9.5 2-2"/><path d="m8.5 6.5 2-2"/><path d="m17.5 15.5 2-2"/></svg>`,
};

// ===== STATE MANAGEMENT =====
const DB_NAME = 'PDFReaderPro';
const DB_VERSION = 2;

class Store {
  constructor() {
    this.state = {
      view: 'library',
      theme: localStorage.getItem('pdfr-theme') || 'light',
      documents: JSON.parse(localStorage.getItem('pdfr-docs') || '[]'),
      currentDoc: null,
      currentPage: 1,
      totalPages: 0,
      zoom: 1,
      fitMode: 'width',
      sidePanel: false,
      sidePanelTab: 'thumbnails',
      searchOpen: false,
      searchQuery: '',
      searchResults: [],
      bookmarks: JSON.parse(localStorage.getItem('pdfr-bookmarks') || '{}'),
      annotations: JSON.parse(localStorage.getItem('pdfr-annotations') || '{}'),
      annotationMode: null,
      annoMenuOpen: false,
      highlightColor: 'yellow',
      focusMode: false,
      showRuler: false,
      rulerY: 300,
      settingsOpen: false,
      showAnnotationBar: true,
      continuousScroll: true,
      toast: null,
      isDragging: false,
      pdfDoc: null,
      outline: [],
      loading: false,
      loadProgress: 0,
      undoStack: [],
    };
    this.listeners = new Set();
    this._prevView = 'library';
  }

  getState() { return this.state; }

  setState(updates) {
    const prev = this.state;
    this.state = { ...this.state, ...updates };
    this.listeners.forEach(fn => fn(this.state, prev));
  }

  subscribe(fn) {
    this.listeners.add(fn);
    return () => this.listeners.delete(fn);
  }

  persistDocs() {
    const docs = this.state.documents.map(d => ({
      id: d.id, name: d.name, pageCount: d.pageCount,
      lastPage: d.lastPage, lastOpened: d.lastOpened, progress: d.progress, size: d.size
    }));
    localStorage.setItem('pdfr-docs', JSON.stringify(docs));
  }

  persistBookmarks() {
    localStorage.setItem('pdfr-bookmarks', JSON.stringify(this.state.bookmarks));
  }

  persistAnnotations() {
    localStorage.setItem('pdfr-annotations', JSON.stringify(this.state.annotations));
  }

  setTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('pdfr-theme', theme);
    this.setState({ theme });
  }
}

const store = new Store();
document.documentElement.setAttribute('data-theme', store.getState().theme);

// ===== INDEXEDDB STORAGE =====
class DocStorage {
  async open() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains('files')) {
          db.createObjectStore('files', { keyPath: 'id' });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async saveFile(docId, arrayBuffer) {
    try {
      const db = await this.open();
      const tx = db.transaction('files', 'readwrite');
      tx.objectStore('files').put({ id: docId, data: arrayBuffer });
      return new Promise((resolve, reject) => {
        tx.oncomplete = () => { warnIfStorageLow(); resolve(); };
        tx.onerror = () => reject(tx.error);
      });
    } catch (e) {
      if (e.name === 'QuotaExceededError') {
        showToast('Storage full. Please delete some PDFs to free space.');
      } else {
        console.warn('IndexedDB save failed:', e);
        showToast('Failed to save PDF locally.');
      }
    }
  }

  async getFile(docId) {
    try {
      const db = await this.open();
      const tx = db.transaction('files', 'readonly');
      const req = tx.objectStore('files').get(docId);
      return new Promise((resolve, reject) => {
        req.onsuccess = () => resolve(req.result?.data || null);
        req.onerror = () => reject(req.error);
      });
    } catch (e) {
      console.warn('IndexedDB read failed:', e);
      return null;
    }
  }

  async deleteFile(docId) {
    try {
      const db = await this.open();
      const tx = db.transaction('files', 'readwrite');
      tx.objectStore('files').delete(docId);
    } catch (e) {
      console.warn('IndexedDB delete failed:', e);
    }
  }
}

const docStorage = new DocStorage();

// ===== PDF ENGINE =====
class PDFEngine {
  constructor() {
    this.doc = null;
    this.renderTasks = new Map();
    this.pageTextContents = new Map();
    this.pageDimCache = new Map();
    this.renderScale = window.devicePixelRatio || 1;
    this._lastBuffer = null;
  }

  async loadDocument(file, onProgress) {
    const arrayBuffer = await file.arrayBuffer();
    return this.loadFromBuffer(arrayBuffer, onProgress);
  }

  async loadFromBuffer(arrayBuffer, onProgress) {
    this._lastBuffer = arrayBuffer;
    this.pageDimCache.clear();
    this.pageTextContents.clear();
    this.renderTasks.forEach(t => { try { t.cancel(); } catch(_){} });
    this.renderTasks.clear();

    const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
    if (onProgress) {
      loadingTask.onProgress = ({ loaded, total }) => {
        if (total > 0) onProgress(Math.min(99, Math.round((loaded / total) * 100)));
      };
    }
    this.doc = await loadingTask.promise;

    // Cache page 1 dimensions immediately (needed for scale calc)
    const p1 = await this.doc.getPage(1);
    const vp1 = p1.getViewport({ scale: 1 });
    this.pageDimCache.set(1, { width: vp1.width, height: vp1.height });

    // Get outline in background (don't block)
    let outline = [];
    this.doc.getOutline().then(ol => {
      if (ol) this.processOutline(ol).then(o => { outline = o; });
    }).catch(() => {});

    return { doc: this.doc, pageCount: this.doc.numPages, outline, arrayBuffer };
  }

  async processOutline(items, level = 0) {
    const result = [];
    for (const item of items) {
      let pageNum = 1;
      try {
        if (item.dest) {
          const dest = typeof item.dest === 'string'
            ? await this.doc.getDestination(item.dest)
            : item.dest;
          if (dest) {
            const idx = await this.doc.getPageIndex(dest[0]);
            pageNum = idx + 1;
          }
        }
      } catch(_) {}
      const entry = { title: item.title, page: pageNum, level, children: [] };
      if (item.items && item.items.length > 0) {
        entry.children = await this.processOutline(item.items, level + 1);
      }
      result.push(entry);
    }
    return result;
  }

  async renderPage(pageNum, canvas, scale = 1) {
    if (this.renderTasks.has(pageNum)) {
      try { this.renderTasks.get(pageNum).cancel(); } catch(_) {}
    }
    const page = await this.doc.getPage(pageNum);

    // Cache unscaled dims so we never need to getPage again for dimensions
    if (!this.pageDimCache.has(pageNum)) {
      const vp0 = page.getViewport({ scale: 1 });
      this.pageDimCache.set(pageNum, { width: vp0.width, height: vp0.height });
    }

    const viewport = page.getViewport({ scale: scale * this.renderScale });

    canvas.width = viewport.width;
    canvas.height = viewport.height;
    canvas.style.width = (viewport.width / this.renderScale) + 'px';
    canvas.style.height = (viewport.height / this.renderScale) + 'px';

    const ctx = canvas.getContext('2d');
    const renderTask = page.render({ canvasContext: ctx, viewport });
    this.renderTasks.set(pageNum, renderTask);

    try {
      await renderTask.promise;
    } catch (e) {
      if (e.name !== 'RenderingCancelled') throw e;
    }
    this.renderTasks.delete(pageNum);
    return { width: viewport.width / this.renderScale, height: viewport.height / this.renderScale };
  }

  async renderTextLayer(pageNum, container, scale) {
    const existing = container.querySelector('.text-layer');
    if (existing) existing.remove();

    const page = await this.doc.getPage(pageNum);
    const viewport = page.getViewport({ scale });
    const textContent = await page.getTextContent();

    const textLayer = document.createElement('div');
    textLayer.className = 'text-layer';
    textLayer.style.width = (viewport.width / this.renderScale) + 'px';
    textLayer.style.height = (viewport.height / this.renderScale) + 'px';

    for (const item of textContent.items) {
      if (!item.str) continue;
      const span = document.createElement('span');
      const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
      const fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);
      const divHeight = fontHeight / this.renderScale;
      span.style.left = (tx[4] / this.renderScale) + 'px';
      span.style.top = ((tx[5] - fontHeight) / this.renderScale) + 'px';
      span.style.fontSize = divHeight + 'px';
      span.style.fontFamily = 'sans-serif';
      span.textContent = item.str;

      if (item.width > 0) {
        const targetW = item.width * scale;
        span.style.width = (targetW / this.renderScale) + 'px';
        span.dataset.targetW = (targetW / this.renderScale);
      }
      textLayer.appendChild(span);
    }
    container.appendChild(textLayer);

    // Adjust scaleX to match PDF glyph widths
    requestAnimationFrame(() => {
      for (const span of textLayer.querySelectorAll('span')) {
        if (span.dataset.targetW && span.textContent.trim()) {
          const targetW = parseFloat(span.dataset.targetW);
          const actualW = span.getBoundingClientRect().width;
          if (actualW > 0 && Math.abs(targetW - actualW) > 1) {
            span.style.transform = `scaleX(${targetW / actualW})`;
            span.style.transformOrigin = '0% 0%';
          }
          delete span.dataset.targetW;
        }
      }
    });
  }

  async renderThumbnail(pageNum, canvas, width = 120) {
    const page = await this.doc.getPage(pageNum);
    const vp = page.getViewport({ scale: 1 });
    const scale = width / vp.width;
    const viewport = page.getViewport({ scale });
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    canvas.style.width = viewport.width + 'px';
    canvas.style.height = viewport.height + 'px';
    const ctx = canvas.getContext('2d');
    await page.render({ canvasContext: ctx, viewport }).promise;
  }

  async getPageText(pageNum) {
    if (this.pageTextContents.has(pageNum)) return this.pageTextContents.get(pageNum);
    const page = await this.doc.getPage(pageNum);
    const content = await page.getTextContent();
    const text = content.items.map(item => item.str).join(' ');
    this.pageTextContents.set(pageNum, text);
    return text;
  }

  async searchText(query) {
    if (!query || !this.doc) return [];
    const results = [];
    const lowerQuery = query.toLowerCase();
    for (let i = 1; i <= this.doc.numPages; i++) {
      const text = await this.getPageText(i);
      const lowerText = text.toLowerCase();
      let idx = 0;
      while ((idx = lowerText.indexOf(lowerQuery, idx)) !== -1) {
        const start = Math.max(0, idx - 40);
        const end = Math.min(text.length, idx + query.length + 40);
        let context = text.substring(start, end);
        if (start > 0) context = '...' + context;
        if (end < text.length) context += '...';
        results.push({ page: i, context, matchIndex: idx - start + (start > 0 ? 3 : 0), matchLength: query.length });
        idx += query.length;
      }
    }
    return results;
  }

  async getPageDimensions(pageNum) {
    if (this.pageDimCache.has(pageNum)) return this.pageDimCache.get(pageNum);
    const page = await this.doc.getPage(pageNum);
    const vp = page.getViewport({ scale: 1 });
    const dims = { width: vp.width, height: vp.height };
    this.pageDimCache.set(pageNum, dims);
    return dims;
  }
}

const engine = new PDFEngine();

// ===== UTILITY =====
function generateId() { return Date.now().toString(36) + Math.random().toString(36).substr(2); }

function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / 1048576).toFixed(1) + ' MB';
}

function formatDate(ts) {
  const d = new Date(ts);
  const now = new Date();
  const diff = now - d;
  if (diff < 60000) return 'Just now';
  if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
  if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
  if (diff < 604800000) return Math.floor(diff / 86400000) + 'd ago';
  return d.toLocaleDateString();
}

function showToast(msg) {
  store.setState({ toast: msg });
  setTimeout(() => store.setState({ toast: null }), 2500);
}

function showNoteDialog(selectedText, onSave) {
  const hasQuote = selectedText && selectedText.trim().length > 0;
  const quoteHtml = hasQuote
    ? `<div style="font-size:12px;color:var(--text-tertiary);margin-bottom:12px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">"${escapeHtml(selectedText.slice(0, 60))}${selectedText.length > 60 ? '...' : ''}"</div>`
    : '';

  const overlay = document.createElement('div');
  overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.4);z-index:9999;display:flex;align-items:center;justify-content:center;padding:20px';
  overlay.innerHTML = `
    <div style="background:var(--bg-canvas);border-radius:var(--radius-lg);padding:20px;width:100%;max-width:360px;box-shadow:var(--shadow-lg)">
      <div style="font-weight:600;font-size:15px;margin-bottom:${hasQuote ? '4' : '12'}px">${hasQuote ? 'Add Note' : 'Quick Note'}</div>
      ${quoteHtml}
      <textarea id="note-input" rows="4" placeholder="Write your note..." autofocus
        style="width:100%;padding:10px;border:1px solid var(--border-strong);border-radius:var(--radius-sm);font-family:var(--font-ui);font-size:14px;resize:vertical;background:var(--bg-primary);color:var(--text-primary)"></textarea>
      <div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end">
        <button id="note-cancel" style="padding:8px 16px;border-radius:var(--radius-sm);font-size:13px;color:var(--text-secondary);background:var(--bg-secondary);cursor:pointer">Cancel</button>
        <button id="note-save" style="padding:8px 16px;border-radius:var(--radius-sm);font-size:13px;color:white;background:var(--accent);font-weight:600;cursor:pointer">Save</button>
      </div>
    </div>`;
  document.body.appendChild(overlay);
  const input = overlay.querySelector('#note-input');
  setTimeout(() => input.focus(), 50);
  overlay.querySelector('#note-cancel').onclick = () => overlay.remove();
  overlay.querySelector('#note-save').onclick = () => {
    const text = input.value.trim();
    if (text) { onSave(text); }
    overlay.remove();
  };
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); overlay.querySelector('#note-save').click(); }
    if (e.key === 'Escape') overlay.remove();
  });
  overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
}

function escapeHtml(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

// ===== FILE HANDLING =====
async function handleFileOpen(file) {
  if (!file || file.type !== 'application/pdf') {
    showToast('Please select a valid PDF file');
    return;
  }
  store.setState({ loading: true, loadProgress: 0, view: 'reader' });

  try {
    // Read file buffer and make a copy for IndexedDB before pdf.js detaches the original
    const arrayBuffer = await file.arrayBuffer();
    const bufferForDB = arrayBuffer.slice(0);

    const { doc, pageCount, outline } = await engine.loadFromBuffer(arrayBuffer, (pct) => {
      store.setState({ loadProgress: pct });
    });

    const docId = generateId();
    const docInfo = {
      id: docId,
      name: file.name.replace(/\.pdf$/i, ''),
      pageCount,
      lastPage: 1,
      lastOpened: Date.now(),
      progress: 0,
      size: file.size,
    };

    // Check if doc already exists
    const existing = store.getState().documents.find(d => d.name === docInfo.name && d.size === file.size);
    if (existing) {
      docInfo.id = existing.id;
      docInfo.lastPage = existing.lastPage || 1;
      docInfo.progress = existing.progress || 0;
      const docs = store.getState().documents.map(d => d.id === existing.id ? { ...d, ...docInfo } : d);
      store.setState({ documents: docs });
    } else {
      store.setState({ documents: [...store.getState().documents, docInfo] });
    }

    // Persist PDF data to IndexedDB (using the pre-detachment copy)
    docStorage.saveFile(docInfo.id, bufferForDB).catch(() => {});

    store.setState({
      currentDoc: docInfo,
      pdfDoc: doc,
      totalPages: pageCount,
      currentPage: docInfo.lastPage,
      outline,
      loading: false,
      loadProgress: 0,
      zoom: 1,
      fitMode: 'width',
      undoStack: [],
    });
    store.persistDocs();

    requestAnimationFrame(() => window.dispatchEvent(new Event('pdf-loaded')));
  } catch (err) {
    console.error('Failed to load PDF:', err);
    store.setState({ loading: false, loadProgress: 0, view: 'library' });
    if (err.name === 'PasswordException') {
      showToast('This PDF is password-protected.');
    } else {
      showToast('Failed to load PDF. The file may be corrupted.');
    }
  }
}

async function handleOpenFromLibrary(docId) {
  const doc = store.getState().documents.find(d => d.id === docId);
  if (!doc) return;

  store.setState({ loading: true, loadProgress: 0, view: 'reader' });

  try {
    const buffer = await docStorage.getFile(docId);
    if (buffer) {
      const { doc: pdfDoc, pageCount, outline } = await engine.loadFromBuffer(buffer, (pct) => {
        store.setState({ loadProgress: pct });
      });
      store.setState({
        currentDoc: { ...doc, lastOpened: Date.now() },
        pdfDoc,
        totalPages: pageCount,
        currentPage: doc.lastPage || 1,
        outline,
        loading: false,
        zoom: 1,
        fitMode: 'width',
        undoStack: [],
      });
      const docs = store.getState().documents.map(d => d.id === docId ? { ...d, lastOpened: Date.now() } : d);
      store.setState({ documents: docs });
      store.persistDocs();
      requestAnimationFrame(() => window.dispatchEvent(new Event('pdf-loaded')));
    } else {
      store.setState({ loading: false, view: 'library' });
      showToast('File not found. Please re-open the PDF.');
      promptFileOpen();
    }
  } catch (err) {
    console.error('Failed to open from library:', err);
    store.setState({ loading: false, view: 'library' });
    showToast('Failed to open document.');
  }
}

async function deleteDocument(docId) {
  await docStorage.deleteFile(docId);
  const docs = store.getState().documents.filter(d => d.id !== docId);
  const bookmarks = { ...store.getState().bookmarks };
  delete bookmarks[docId];
  const annotations = { ...store.getState().annotations };
  delete annotations[docId];
  store.setState({ documents: docs, bookmarks, annotations });
  store.persistDocs();
  store.persistBookmarks();
  store.persistAnnotations();
  showToast('Document removed');
}

function promptFileOpen() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.pdf';
  input.onchange = (e) => { if (e.target.files[0]) handleFileOpen(e.target.files[0]); };
  input.click();
}

// ===== RENDER FUNCTIONS =====
let currentView = null;

function renderApp() {
  const state = store.getState();
  const root = document.getElementById('root');
  currentView = state.view;

  if (state.view === 'library') {
    root.innerHTML = renderLibrary(state);
    attachLibraryEvents();
  } else {
    root.innerHTML = renderReader(state);
    attachReaderEvents();
  }
}

// ===== LIBRARY VIEW =====
function renderLibrary(state) {
  const docs = state.documents.sort((a, b) => (b.lastOpened || 0) - (a.lastOpened || 0));

  return `
    <div class="app-shell" data-view="library">
      ${state.isDragging ? `
        <div class="drop-zone-overlay">
          <div class="drop-zone-box">
            ${Icons.upload}
            <h3>Drop PDF Here</h3>
            <p>Release to open your document</p>
          </div>
        </div>
      ` : ''}

      <div class="library">
        <div class="library-header">
          <div class="library-brand">
            <div class="library-logo">P</div>
            <div>
              <div class="library-title">PDF Reader Pro</div>
              <div class="library-subtitle">Your reading workspace</div>
            </div>
          </div>

          <div class="library-actions">
            <button class="lib-btn lib-btn-primary" id="btn-open-file" aria-label="Open PDF file">
              ${Icons.plus} Open PDF
            </button>
            <button class="lib-btn lib-btn-secondary" id="btn-settings-lib" aria-label="Settings">
              ${Icons.settings}
            </button>
          </div>

          ${docs.length > 0 ? `
            <div class="library-search">
              ${Icons.search}
              <input type="text" placeholder="Search your library..." id="lib-search-input" aria-label="Search library">
            </div>

            <div class="library-tabs">
              <button class="lib-tab active" data-tab="recent">Recent</button>
              <button class="lib-tab" data-tab="all">All Files</button>
            </div>
          ` : ''}
        </div>

        <div class="library-content">
          ${docs.length === 0 ? `
            <div class="library-empty">
              <div class="library-empty-icon">${Icons.file}</div>
              <h3>Your library is empty</h3>
              <p>Open a PDF to get started. You can also drag and drop files here.</p>
            </div>
          ` : `
            <div class="library-grid" id="library-grid">
              ${docs.map((doc, i) => `
                <div class="doc-card" data-doc-id="${escapeHtml(doc.id)}" style="animation-delay: ${i * 0.05}s">
                  <div class="doc-card-thumb">
                    <button class="doc-card-delete" data-delete-id="${escapeHtml(doc.id)}" aria-label="Delete document" title="Remove">${Icons.trash}</button>
                    <div class="thumb-placeholder">
                      ${Icons.file}
                      <span style="font-size:11px; font-weight:500;">${doc.pageCount || '?'} pages</span>
                    </div>
                    ${doc.progress > 0 ? `
                      <div class="doc-card-progress">
                        <div class="doc-card-progress-bar" style="width:${Math.round(doc.progress * 100)}%"></div>
                      </div>
                    ` : ''}
                  </div>
                  <div class="doc-card-info">
                    <div class="doc-card-title">${escapeHtml(doc.name)}</div>
                    <div class="doc-card-meta">
                      <span>${formatFileSize(doc.size || 0)}</span>
                      <span>&middot;</span>
                      <span>${formatDate(doc.lastOpened)}</span>
                    </div>
                  </div>
                </div>
              `).join('')}
            </div>
          `}
        </div>
      </div>

      ${state.settingsOpen ? renderSettingsModal(state) : ''}
      ${state.toast ? `<div class="toast" role="status" aria-live="polite">${escapeHtml(state.toast)}</div>` : ''}
    </div>
  `;
}

// ===== READER VIEW =====
function renderReader(state) {
  const isBookmarked = state.bookmarks[state.currentDoc?.id]?.includes(state.currentPage);

  return `
    <div class="app-shell ${state.focusMode ? 'focus-mode' : ''}" data-view="reader">
      <div class="reader-shell">
        ${state.loading ? `<div class="load-progress"><div class="load-progress-bar" style="width:${state.loadProgress || 5}%"></div></div>` : ''}
        <div class="reader-topbar ${state.focusMode ? 'hidden' : ''}">
          <button class="topbar-btn" id="btn-back" title="Back to Library" aria-label="Back to Library">${Icons.back}</button>
          <button class="topbar-btn ${state.sidePanel ? 'active' : ''}" id="btn-sidebar" title="Toggle Sidebar" aria-label="Toggle Sidebar">${Icons.sidebar}</button>
          <div class="topbar-sep"></div>
          <div class="topbar-title">${escapeHtml(state.currentDoc?.name || 'Document')}</div>
          <div class="topbar-sep"></div>
          <button class="topbar-btn" id="btn-zoom-out" title="Zoom Out" aria-label="Zoom Out">${Icons.zoomOut}</button>
          <span id="zoom-display" style="font-size:12px;font-weight:600;color:var(--text-tertiary);min-width:40px;text-align:center;font-variant-numeric:tabular-nums">${Math.round(state.zoom * 100)}%</span>
          <button class="topbar-btn" id="btn-zoom-in" title="Zoom In" aria-label="Zoom In">${Icons.zoomIn}</button>
          <div class="topbar-sep"></div>
          <button class="topbar-btn" id="btn-search" title="Search (Ctrl+F)" aria-label="Search">${Icons.search}</button>
          <button class="topbar-btn" id="btn-bookmark" title="Bookmark (Ctrl+B)" aria-label="Bookmark">${isBookmarked ? Icons.bookmarkFill : Icons.bookmark}</button>
          <button class="topbar-btn" id="btn-focus" title="Focus Mode" aria-label="Focus Mode">${Icons.focus}</button>
          <button class="topbar-btn" id="btn-ruler" title="Reading Ruler" aria-label="Reading Ruler">${Icons.ruler}</button>
          <button class="topbar-btn" id="btn-settings" title="Settings" aria-label="Settings">${Icons.settings}</button>
        </div>

        <div class="reader-body">
          ${state.sidePanel ? renderSidePanel(state) : ''}
          <div class="reading-canvas" id="reading-canvas" role="main">
            ${state.loading ? `
              <div class="loading-wrap">
                <div class="spinner"></div>
                <span>Loading document...</span>
              </div>
            ` : `
              <div class="page-container" id="page-container"></div>
            `}
          </div>
        </div>

        <div class="reader-statusbar ${state.focusMode ? 'hidden' : ''}">
          <div class="status-left">
            <span id="page-info">Page <strong>${state.currentPage}</strong> of ${state.totalPages}</span>
            <div class="status-divider"></div>
            <div class="page-slider-wrap">
              <input type="range" class="page-slider" id="page-slider"
                min="1" max="${state.totalPages}" value="${state.currentPage}" aria-label="Page slider">
            </div>
          </div>
          <div class="status-right">
            <span id="zoom-info">${Math.round(state.zoom * 100)}%</span>
            <div class="status-divider"></div>
            <span id="read-pct">${Math.round((state.currentPage / Math.max(state.totalPages, 1)) * 100)}% read</span>
          </div>
        </div>

        ${state.searchOpen ? renderSearchOverlay(state) : ''}
        ${!state.focusMode && !state.loading ? renderAnnotationToolbar(state) : ''}
      </div>

      ${state.showRuler ? `<div class="reading-ruler" style="top:${state.rulerY}px"></div>` : ''}
      ${state.settingsOpen ? renderSettingsModal(state) : ''}
      ${state.toast ? `<div class="toast" role="status" aria-live="polite">${escapeHtml(state.toast)}</div>` : ''}
    </div>
  `;
}

function renderSidePanel(state) {
  const isMobile = window.innerWidth <= 768;
  return `
    ${isMobile ? '<div class="sidebar-backdrop" id="sidebar-backdrop"></div>' : ''}
    <div class="side-panel" role="navigation">
      <div class="side-panel-tabs">
        <button class="sp-tab ${state.sidePanelTab === 'thumbnails' ? 'active' : ''}" data-sptab="thumbnails">Pages</button>
        <button class="sp-tab ${state.sidePanelTab === 'outline' ? 'active' : ''}" data-sptab="outline">Outline</button>
        <button class="sp-tab ${state.sidePanelTab === 'bookmarks' ? 'active' : ''}" data-sptab="bookmarks">Bookmarks</button>
        <button class="sp-tab ${state.sidePanelTab === 'annotations' ? 'active' : ''}" data-sptab="annotations">Notes</button>
      </div>
      <div class="side-panel-content" id="sp-content">
        ${renderSidePanelContent(state)}
      </div>
    </div>
  `;
}

function renderSidePanelContent(state) {
  switch (state.sidePanelTab) {
    case 'thumbnails':
      return `<div class="thumb-grid" id="thumb-grid">
        ${Array.from({ length: state.totalPages }, (_, i) => `
          <div class="thumb-item ${state.currentPage === i + 1 ? 'active' : ''}" data-page="${i + 1}">
            <canvas id="thumb-canvas-${i + 1}"></canvas>
            <span class="thumb-label">Page ${i + 1}</span>
          </div>
        `).join('')}
      </div>`;
    case 'outline':
      if (!state.outline || state.outline.length === 0) {
        return `<div style="padding:20px;text-align:center;color:var(--text-tertiary);font-size:13px">No outline available for this document</div>`;
      }
      return renderOutlineItems(state.outline);
    case 'bookmarks':
      const docBookmarks = state.bookmarks[state.currentDoc?.id] || [];
      if (docBookmarks.length === 0) {
        return `<div style="padding:20px;text-align:center;color:var(--text-tertiary);font-size:13px">No bookmarks yet. Click the bookmark icon to add one.</div>`;
      }
      return docBookmarks.map(p => `
        <div class="bookmark-item" data-page="${p}">
          <div class="bookmark-dot"></div>
          <div class="bookmark-info">
            <div class="bookmark-page">Page ${p}</div>
            <div class="bookmark-label">Bookmarked</div>
          </div>
          <button class="bookmark-remove topbar-btn" data-remove-bm="${p}" style="width:28px;height:28px" aria-label="Remove bookmark">${Icons.trash}</button>
        </div>
      `).join('');
    case 'annotations':
      const docAnnos = state.annotations[state.currentDoc?.id] || [];
      if (docAnnos.length === 0) {
        return `<div style="padding:20px;text-align:center;color:var(--text-tertiary);font-size:13px">No annotations yet. Select the note tool and tap anywhere on a page to add a note, or select text to highlight.</div>`;
      }
      return docAnnos.sort((a, b) => a.page - b.page).map(a => {
        const label = a.type === 'note' && a.content ? a.content : (a.text || 'Highlight');
        const typeLabel = a.type === 'note' && !a.rects ? 'pin note' : a.type;
        return `
        <div class="annotation-item" data-page="${a.page}"
             style="border-left-color: var(--highlight-${a.color || 'yellow'})">
          <div class="annotation-text">${escapeHtml(label)}</div>
          <div class="annotation-meta">Page ${a.page} &middot; ${typeLabel} &middot; ${formatDate(a.created)}</div>
        </div>`;
      }).join('');
    default:
      return '';
  }
}

function renderOutlineItems(items) {
  return items.map(item => `
    <div class="outline-item outline-item-l${Math.min(item.level + 1, 3)}" data-page="${item.page}">
      ${escapeHtml(item.title)}
    </div>
    ${item.children ? renderOutlineItems(item.children) : ''}
  `).join('');
}

function renderSearchOverlay(state) {
  return `
    <div class="search-overlay" id="search-overlay">
      <div class="search-input-wrap">
        ${Icons.search}
        <input type="text" placeholder="Search in document..." id="search-input"
               value="${escapeHtml(state.searchQuery)}" autofocus aria-label="Search in document">
        <button class="topbar-btn" id="btn-close-search" style="width:28px;height:28px" aria-label="Close search">${Icons.x}</button>
      </div>
      <div class="search-results" id="search-results">
        ${state.searchResults.length === 0 && state.searchQuery ?
          `<div style="padding:20px;text-align:center;color:var(--text-tertiary);font-size:13px">No results found</div>` :
          state.searchResults.map((r, i) => {
            const before = escapeHtml(r.context.substring(0, r.matchIndex));
            const match = escapeHtml(r.context.substring(r.matchIndex, r.matchIndex + r.matchLength));
            const after = escapeHtml(r.context.substring(r.matchIndex + r.matchLength));
            return `
              <div class="search-result-item" data-page="${r.page}" data-idx="${i}">
                <div class="search-result-page">Page ${r.page}</div>
                <div class="search-result-context">${before}<mark>${match}</mark>${after}</div>
              </div>
            `;
          }).join('')
        }
      </div>
      ${state.searchResults.length > 0 ?
        `<div class="search-count">${state.searchResults.length} result${state.searchResults.length !== 1 ? 's' : ''} found</div>` : ''}
    </div>
  `;
}

function renderAnnotationToolbar(state) {
  const hasMode = !!state.annotationMode;
  return `
    <button class="anno-fab ${hasMode ? 'active' : ''}" id="btn-anno-fab" aria-label="Annotation tools">
      ${hasMode ? Icons.x : Icons.pen}
    </button>
  `;
}

function renderSettingsModal(state) {
  return `
    <div class="modal-overlay" id="modal-overlay">
      <div class="modal-content" role="dialog" aria-label="Settings">
        <div class="modal-header">
          <h2>Settings</h2>
          <button class="topbar-btn" id="btn-close-settings" aria-label="Close settings">${Icons.x}</button>
        </div>
        <div class="modal-body">
          <div class="setting-group">
            <div class="setting-group-title">Appearance</div>
            <div class="setting-row">
              <div>
                <div class="setting-label">Theme</div>
                <div class="setting-desc">Choose your reading theme</div>
              </div>
            </div>
            <div class="theme-picker" style="margin-top:8px">
              <button class="theme-option theme-light ${state.theme === 'light' ? 'active' : ''}" data-theme="light">Light</button>
              <button class="theme-option theme-dark ${state.theme === 'dark' ? 'active' : ''}" data-theme="dark">Dark</button>
              <button class="theme-option theme-sepia ${state.theme === 'sepia' ? 'active' : ''}" data-theme="sepia">Sepia</button>
            </div>
          </div>
          <div class="setting-group">
            <div class="setting-group-title">Reading</div>
            <div class="setting-row">
              <div class="setting-label">Continuous Scroll</div>
              <div class="toggle ${state.continuousScroll ? 'active' : ''}" id="toggle-scroll" role="switch" aria-checked="${state.continuousScroll}"></div>
            </div>
            <div class="setting-row">
              <div class="setting-label">Reading Ruler</div>
              <div class="toggle ${state.showRuler ? 'active' : ''}" id="toggle-ruler" role="switch" aria-checked="${state.showRuler}"></div>
            </div>
          </div>
          <div class="setting-group">
            <div class="setting-group-title">About</div>
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
              <div style="width:40px;height:40px;background:linear-gradient(135deg,#3b82f6,#8b5cf6);border-radius:10px;display:flex;align-items:center;justify-content:center;color:white;font-weight:800;font-size:18px;flex-shrink:0">P</div>
              <div>
                <div style="font-weight:700;font-size:15px;letter-spacing:-0.2px">PDF Reader Pro</div>
                <div style="font-size:12px;color:var(--text-tertiary)">Version 2.0</div>
              </div>
            </div>
            <div style="font-size:13px;color:var(--text-secondary);line-height:1.6">
              A premium PDF reading experience with annotations, bookmarks, and text search. Built with pdf.js.
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
}

// ===== VIRTUALIZED PAGE RENDERING =====
let pagePositions = [];
let renderedPages = new Set();
let effectiveScale = 1;
let _renderingPages = false;
let _builtScale = null;
let _builtMode = null;
let _builtPageCount = 0;

function computePageLayout() {
  const state = store.getState();
  if (!state.pdfDoc) return;

  const canvas = document.getElementById('reading-canvas');
  if (!canvas) return;
  // Account for page-container padding (smaller on mobile)
  const pc = document.getElementById('page-container');
  const padding = pc ? parseFloat(getComputedStyle(pc).paddingLeft) * 2 : 40;
  const canvasWidth = canvas.clientWidth - padding;
  if (canvasWidth <= 0) return;

  const dims1 = engine.pageDimCache.get(1) || { width: 612, height: 792 };
  const fitWidthScale = canvasWidth / dims1.width;
  effectiveScale = state.fitMode === 'width' ? fitWidthScale * state.zoom : state.zoom;

  // Wrapper sizes must be in CSS pixels (NOT divided by dpr).
  // renderPage sets canvas CSS size = dims * effectiveScale, so wrappers must match.
  const defaultH = dims1.height * effectiveScale;
  const defaultW = dims1.width * effectiveScale;

  pagePositions = [];
  let yOffset = 20;
  for (let i = 1; i <= state.totalPages; i++) {
    const cached = engine.pageDimCache.get(i);
    const h = cached ? cached.height * effectiveScale : defaultH;
    const w = cached ? cached.width * effectiveScale : defaultW;
    pagePositions.push({ page: i, top: yOffset, height: h, width: w });
    yOffset += h + 28;
  }
}

function buildPagePlaceholders(force) {
  const container = document.getElementById('page-container');
  if (!container) return;

  const state = store.getState();
  const scaleKey = Math.round(effectiveScale * 1000);
  const modeKey = state.continuousScroll;
  const countKey = state.totalPages;

  // Skip rebuild if layout hasn't changed (prevents destroying rendered canvases)
  if (!force && scaleKey === _builtScale && modeKey === _builtMode && countKey === _builtPageCount && container.children.length > 0) {
    return;
  }

  _builtScale = scaleKey;
  _builtMode = modeKey;
  _builtPageCount = countKey;

  // Cancel any in-flight render tasks before clearing
  engine.renderTasks.forEach(t => { try { t.cancel(); } catch(_){} });
  engine.renderTasks.clear();

  container.innerHTML = '';
  renderedPages.clear();

  const frag = document.createDocumentFragment();

  if (state.continuousScroll) {
    for (const pos of pagePositions) {
      const wrapper = document.createElement('div');
      wrapper.className = 'page-wrapper';
      wrapper.id = `page-wrap-${pos.page}`;
      wrapper.dataset.page = pos.page;
      wrapper.style.cssText = `width:${pos.width}px;height:${pos.height}px;position:relative`;

      const placeholder = document.createElement('div');
      placeholder.className = 'page-placeholder';
      placeholder.style.cssText = 'width:100%;height:100%';
      placeholder.textContent = pos.page;
      wrapper.appendChild(placeholder);

      const label = document.createElement('div');
      label.className = 'page-number-label';
      label.textContent = pos.page;

      frag.appendChild(wrapper);
      frag.appendChild(label);
    }
  } else {
    const pos = pagePositions[state.currentPage - 1];
    if (!pos) return;
    const wrapper = document.createElement('div');
    wrapper.className = 'page-wrapper';
    wrapper.id = `page-wrap-${pos.page}`;
    wrapper.dataset.page = pos.page;
    wrapper.style.cssText = `width:${pos.width}px;height:${pos.height}px;position:relative`;

    const label = document.createElement('div');
    label.className = 'page-number-label';
    label.textContent = `Page ${state.currentPage} of ${state.totalPages}`;

    frag.appendChild(wrapper);
    frag.appendChild(label);
  }

  container.appendChild(frag);
}

async function renderVisiblePages(forceRebuild) {
  const state = store.getState();
  if (!state.pdfDoc || state.loading || _renderingPages) return;
  _renderingPages = true;

  try {
    computePageLayout();
    if (pagePositions.length === 0) { _renderingPages = false; return; }

    buildPagePlaceholders(forceRebuild);

    if (state.continuousScroll) {
      if (forceRebuild) {
        const wrapper = document.getElementById(`page-wrap-${state.currentPage}`);
        if (wrapper) wrapper.scrollIntoView({ block: 'start' });
      }
      await renderVisiblePagesLazy();
    } else {
      await renderSinglePage(state.currentPage);
    }
  } catch (e) {
    console.error('renderVisiblePages error:', e);
  }
  _renderingPages = false;
}

async function renderSinglePage(pageNum) {
  const wrapper = document.getElementById(`page-wrap-${pageNum}`);
  if (!wrapper || renderedPages.has(pageNum)) return;
  renderedPages.add(pageNum);

  // Clear placeholder
  const ph = wrapper.querySelector('.page-placeholder');
  if (ph) ph.remove();

  if (!wrapper.querySelector('canvas')) {
    const cvs = document.createElement('canvas');
    cvs.id = `page-canvas-${pageNum}`;
    wrapper.appendChild(cvs);
  }

  const cvs = wrapper.querySelector('canvas');

  // Render canvas (visual priority)
  try {
    await engine.renderPage(pageNum, cvs, effectiveScale);

    // Correct wrapper size if actual dims differ from assumed (dims already cached by renderPage)
    const dims = engine.pageDimCache.get(pageNum);
    if (dims) {
      const actualH = dims.height * effectiveScale;
      const actualW = dims.width * effectiveScale;
      if (Math.abs(wrapper.clientHeight - actualH) > 2) {
        wrapper.style.width = actualW + 'px';
        wrapper.style.height = actualH + 'px';
      }
    }
  } catch (e) {
    if (e.name !== 'RenderingCancelled') console.error('Page render error:', e);
    return;
  }

  // Defer text layer & overlays — don't block the visual render
  requestAnimationFrame(() => {
    engine.renderTextLayer(pageNum, wrapper, effectiveScale).catch(() => {});
    renderHighlightsForPage(pageNum, wrapper);
    renderFreehandForPage(pageNum, wrapper);
    setupDrawingForPage(pageNum, wrapper);
  });
}

async function renderVisiblePagesLazy() {
  const canvas = document.getElementById('reading-canvas');
  if (!canvas || pagePositions.length === 0) return;

  const scrollTop = canvas.scrollTop;
  const viewHeight = canvas.clientHeight;
  const buffer = viewHeight;

  const pagesToRender = [];
  const pagesToUnload = [];

  for (const pos of pagePositions) {
    const pageBottom = pos.top + pos.height;
    const inRange = pageBottom > (scrollTop - buffer) && pos.top < (scrollTop + viewHeight + buffer);

    if (inRange && !renderedPages.has(pos.page)) {
      pagesToRender.push(pos.page);
    } else if (!inRange && renderedPages.has(pos.page)) {
      const farAway = pos.top > (scrollTop + viewHeight * 5) || pageBottom < (scrollTop - viewHeight * 5);
      if (farAway) pagesToUnload.push(pos.page);
    }
  }

  // Unload far pages to save memory
  for (const p of pagesToUnload) {
    const wrapper = document.getElementById(`page-wrap-${p}`);
    if (wrapper) {
      const pos = pagePositions[p - 1];
      wrapper.innerHTML = `<div class="page-placeholder" style="width:100%;height:100%">${p}</div>`;
      wrapper.style.width = pos.width + 'px';
      wrapper.style.height = pos.height + 'px';
      renderedPages.delete(p);
    }
  }

  // Render visible pages in parallel (max 3 concurrent)
  const BATCH = 3;
  for (let i = 0; i < pagesToRender.length; i += BATCH) {
    await Promise.all(pagesToRender.slice(i, i + BATCH).map(p => renderSinglePage(p)));
  }
}

async function renderThumbnails() {
  const state = store.getState();
  if (!state.pdfDoc) return;
  const startPage = Math.max(1, state.currentPage - 5);
  const endPage = Math.min(state.totalPages, state.currentPage + 10);
  for (let i = startPage; i <= endPage; i++) {
    const canvas = document.getElementById(`thumb-canvas-${i}`);
    if (canvas && !canvas.dataset.rendered) {
      canvas.dataset.rendered = 'true';
      engine.renderThumbnail(i, canvas, 60).catch(() => {});
    }
  }
}

// ===== HIGHLIGHT / ANNOTATION RENDERING =====
function renderHighlightsForPage(pageNum, wrapper) {
  wrapper.querySelectorAll('.highlight-overlay, .note-pin').forEach(el => el.remove());

  const state = store.getState();
  const docId = state.currentDoc?.id;
  const docAnnos = state.annotations[docId] || [];
  const wW = wrapper.clientWidth;
  const wH = wrapper.clientHeight;

  // Render rect-based annotations (highlights, underlines, text-attached notes)
  const rectAnnos = docAnnos.filter(a => a.page === pageNum && a.rects);
  for (const anno of rectAnnos) {
    for (const rect of anno.rects) {
      const overlay = document.createElement('div');
      overlay.className = 'highlight-overlay';
      overlay.style.left = (rect.xPct * wW) + 'px';
      overlay.style.top = (rect.yPct * wH) + 'px';
      overlay.style.width = (rect.widthPct * wW) + 'px';
      overlay.style.height = (rect.heightPct * wH) + 'px';

      if (anno.type === 'underline') {
        overlay.style.background = 'transparent';
        overlay.style.borderBottom = `2px solid var(--highlight-${anno.color || 'yellow'})`;
      } else {
        overlay.style.background = `var(--highlight-${anno.color || 'yellow'})`;
      }

      if (anno.type === 'note' && anno.content) {
        overlay.style.cursor = 'pointer';
        overlay.title = anno.content;
        overlay.style.pointerEvents = 'auto';
        overlay.addEventListener('click', () => showNotePopover(anno, overlay, wrapper));
      }

      wrapper.appendChild(overlay);
    }
  }

  // Render positioned note pins (tap-to-add notes without text selection)
  const pinAnnos = docAnnos.filter(a => a.page === pageNum && a.type === 'note' && a.xPct != null && !a.rects);
  for (const anno of pinAnnos) {
    const pin = document.createElement('div');
    pin.className = 'note-pin';
    pin.style.left = (anno.xPct * wW - 14) + 'px';
    pin.style.top = (anno.yPct * wH - 14) + 'px';
    pin.style.background = `var(--highlight-${anno.color || 'yellow'})`;
    pin.innerHTML = Icons.note.replace(/width="18" height="18"/, 'width="14" height="14"');
    pin.title = anno.content || '';
    pin.addEventListener('click', (e) => { e.stopPropagation(); showNotePopover(anno, pin, wrapper); });
    wrapper.appendChild(pin);
  }
}

// Show a popover with note content, with delete option
function showNotePopover(anno, anchor, wrapper) {
  // Remove any existing popover
  document.querySelectorAll('.note-popover').forEach(el => el.remove());

  const popover = document.createElement('div');
  popover.className = 'note-popover';

  // Position near the anchor
  const wRect = wrapper.getBoundingClientRect();
  const aRect = anchor.getBoundingClientRect();
  let left = aRect.left - wRect.left + aRect.width / 2 - 120;
  let top = aRect.bottom - wRect.top + 6;
  // Keep within bounds
  left = Math.max(4, Math.min(left, wrapper.clientWidth - 248));
  if (top + 200 > wrapper.clientHeight) top = aRect.top - wRect.top - 210;

  popover.style.left = left + 'px';
  popover.style.top = top + 'px';

  const quoteHtml = anno.text ? `<div class="note-popover-quote">${escapeHtml(anno.text.slice(0, 100))}${anno.text.length > 100 ? '...' : ''}</div>` : '';
  popover.innerHTML = `
    ${quoteHtml}
    <div class="note-popover-text">${escapeHtml(anno.content || '')}</div>
    <div class="note-popover-actions">
      <button class="btn-delete" aria-label="Delete note">Delete</button>
      <button class="btn-close" aria-label="Close">Close</button>
    </div>
  `;
  wrapper.appendChild(popover);

  popover.querySelector('.btn-close').addEventListener('click', () => popover.remove());
  popover.querySelector('.btn-delete').addEventListener('click', () => {
    deleteAnnotationById(anno.id);
    renderHighlightsForPage(anno.page, wrapper);
    popover.remove();
    showToast('Note deleted');
  });

  // Close on click outside
  setTimeout(() => {
    document.addEventListener('click', function _closePop(e) {
      if (!popover.contains(e.target) && e.target !== anchor && !anchor.contains(e.target)) {
        popover.remove();
        document.removeEventListener('click', _closePop);
      }
    });
  }, 10);
}

// Delete a specific annotation by ID
function deleteAnnotationById(annoId) {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const annotations = { ...state.annotations };
  annotations[docId] = (annotations[docId] || []).filter(a => a.id !== annoId);
  store.setState({ annotations });
  store.persistAnnotations();
}

function setupTextSelectionHandler() {
  document.addEventListener('mouseup', (e) => {
    const state = store.getState();
    if (state.view !== 'reader') return;
    if (state.annotationMode === 'pen') return;
    // Don't interfere with toolbar clicks
    if (e.target.closest('.selection-toolbar, .anno-menu, .anno-fab')) return;

    // Short delay to let long-press handler finish first
    setTimeout(() => {
      const selection = window.getSelection();
      if (!selection || selection.isCollapsed) return;
      if (!selection.toString().trim()) return;

      // Check the selection is inside a text layer
      const range = selection.getRangeAt(0);
      const startEl = range.startContainer.nodeType === Node.TEXT_NODE ? range.startContainer.parentElement : range.startContainer;
      if (!startEl?.closest('.text-layer')) return;

      // If annotation mode is active, apply directly
      if (state.annotationMode === 'highlight' || state.annotationMode === 'underline' || state.annotationMode === 'note') {
        handleSelectionAction(state.annotationMode);
      } else if (!document.getElementById('selection-toolbar')) {
        // Show toolbar for manual drag-selection
        showSelectionToolbar();
      }
    }, 50);
  });
}

// ===== TAP-TO-ADD-NOTE (positioned notes without text selection) =====
function setupTapToNote() {
  document.addEventListener('click', (e) => {
    const state = store.getState();
    if (state.view !== 'reader' || state.annotationMode !== 'note') return;

    // Don't trigger if clicking on UI elements, existing notes, or popovers
    if (e.target.closest('.note-pin, .note-popover, .anno-menu, .anno-fab, .reader-topbar, .reader-statusbar, .side-panel, .settings-overlay, .search-overlay')) return;

    // Only trigger if there's no text selection (text-selection notes handled in mouseup)
    const selection = window.getSelection();
    if (selection && !selection.isCollapsed && selection.toString().trim()) return;

    // Find the page wrapper that was clicked
    const pageWrapper = e.target.closest('.page-wrapper');
    if (!pageWrapper) return;

    const pageNum = parseInt(pageWrapper.dataset.page);
    if (!pageNum) return;

    const wrapperRect = pageWrapper.getBoundingClientRect();
    const xPct = (e.clientX - wrapperRect.left) / wrapperRect.width;
    const yPct = (e.clientY - wrapperRect.top) / wrapperRect.height;

    // Clamp within page bounds
    if (xPct < 0 || xPct > 1 || yPct < 0 || yPct > 1) return;

    showNoteDialog('', (noteText) => {
      addAnnotation('note', pageNum, { content: noteText, xPct, yPct });
      renderHighlightsForPage(pageNum, pageWrapper);
      showToast('Note added');
    });
  });
}

// ===== LONG-PRESS TO SELECT SENTENCE & SHOW TOOLBAR =====
function setupLongPressHandler() {
  let pressTimer = null;
  let pressX = 0;
  let pressY = 0;
  let moved = false;
  let longPressFired = false;
  const LONG_PRESS_MS = 450;
  const MOVE_THRESHOLD = 10;

  function clearPress() {
    if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
  }

  function handlePressStart(e) {
    const state = store.getState();
    if (state.view !== 'reader') return;
    if (state.annotationMode === 'pen') return;

    const touch = e.touches ? e.touches[0] : e;
    const target = document.elementFromPoint(touch.clientX, touch.clientY);
    if (!target) return;

    // Must be inside a page wrapper (text layer, canvas, or the wrapper itself)
    const pageWrapper = target.closest('.page-wrapper');
    if (!pageWrapper) return;

    // Skip UI elements
    if (target.closest('.selection-toolbar, .anno-menu, .anno-fab, .note-popover, .note-pin, .reader-topbar, .reader-statusbar, .side-panel')) return;

    pressX = touch.clientX;
    pressY = touch.clientY;
    moved = false;
    longPressFired = false;

    pressTimer = setTimeout(() => {
      if (moved) return;
      longPressFired = true;

      const selectedText = selectLineAt(touch.clientX, touch.clientY);
      if (selectedText) {
        if (navigator.vibrate) navigator.vibrate(25);
        showSelectionToolbar();
      }
    }, LONG_PRESS_MS);
  }

  function handlePressMove(e) {
    if (!pressTimer) return;
    const touch = e.touches ? e.touches[0] : e;
    const dx = touch.clientX - pressX;
    const dy = touch.clientY - pressY;
    if (Math.sqrt(dx * dx + dy * dy) > MOVE_THRESHOLD) {
      moved = true;
      clearPress();
    }
  }

  function handlePressEnd() { clearPress(); }

  // Always suppress native context menu on text layer (we have our own toolbar)
  document.addEventListener('contextmenu', (e) => {
    if (e.target.closest('.text-layer') || e.target.closest('.page-wrapper') || e.target.closest('.reading-canvas')) {
      e.preventDefault();
    }
  });

  document.addEventListener('touchstart', handlePressStart, { passive: true });
  document.addEventListener('touchmove', handlePressMove, { passive: true });
  document.addEventListener('touchend', handlePressEnd);
  document.addEventListener('touchcancel', handlePressEnd);
  document.addEventListener('mousedown', (e) => { if (e.button === 0) handlePressStart(e); });
  document.addEventListener('mousemove', handlePressMove);
  document.addEventListener('mouseup', handlePressEnd);
}

// Select the visual line of text at the given point
function selectLineAt(x, y) {
  // Find the nearest text using caretRangeFromPoint (works even when touch
  // hits the canvas underneath, not the transparent text span directly)
  let hitSpan = null;

  // Method 1: caretRangeFromPoint (Chrome, Safari)
  if (document.caretRangeFromPoint) {
    const caret = document.caretRangeFromPoint(x, y);
    if (caret && caret.startContainer) {
      const node = caret.startContainer;
      hitSpan = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      if (hitSpan && hitSpan.tagName !== 'SPAN') hitSpan = hitSpan.closest('.text-layer span');
    }
  }

  // Method 2: caretPositionFromPoint (Firefox)
  if (!hitSpan && document.caretPositionFromPoint) {
    const pos = document.caretPositionFromPoint(x, y);
    if (pos && pos.offsetNode) {
      const node = pos.offsetNode;
      hitSpan = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      if (hitSpan && hitSpan.tagName !== 'SPAN') hitSpan = hitSpan.closest('.text-layer span');
    }
  }

  // Method 3: elementFromPoint fallback
  if (!hitSpan) {
    const target = document.elementFromPoint(x, y);
    if (target) hitSpan = target.closest('.text-layer span');
  }

  if (!hitSpan) return null;

  const textLayer = hitSpan.closest('.text-layer');
  if (!textLayer) return null;

  // Get the hit span's vertical center
  const hitRect = hitSpan.getBoundingClientRect();
  const hitYCenter = hitRect.top + hitRect.height / 2;
  const tolerance = Math.max(hitRect.height * 0.7, 8);

  // Collect all spans on the same visual line
  const lineSpans = [];
  const allSpans = textLayer.querySelectorAll('span');
  for (const span of allSpans) {
    if (!span.textContent.trim()) continue;
    const r = span.getBoundingClientRect();
    if (r.width === 0 || r.height === 0) continue;
    const yCenter = r.top + r.height / 2;
    if (Math.abs(yCenter - hitYCenter) <= tolerance) {
      lineSpans.push({ span, left: r.left });
    }
  }

  if (lineSpans.length === 0) return null;

  // Sort by horizontal position (left to right)
  lineSpans.sort((a, b) => a.left - b.left);

  // Select from first to last span on the line
  const firstSpan = lineSpans[0].span;
  const lastSpan = lineSpans[lineSpans.length - 1].span;
  const firstNode = firstSpan.firstChild;
  const lastNode = lastSpan.firstChild;
  if (!firstNode || !lastNode) return null;

  const range = document.createRange();
  range.setStart(firstNode, 0);
  range.setEnd(lastNode, lastNode.textContent.length);

  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);

  return selection.toString().trim() || null;
}

// Show floating toolbar positioned near the current selection
function showSelectionToolbar() {
  dismissSelectionToolbar();

  const selection = window.getSelection();
  if (!selection || selection.isCollapsed) return;
  if (!selection.toString().trim()) return;

  // Get the bounding rect of the selection
  const range = selection.getRangeAt(0);
  const selRect = range.getBoundingClientRect();
  if (selRect.width === 0 && selRect.height === 0) return;

  const toolbar = document.createElement('div');
  toolbar.className = 'selection-toolbar';
  toolbar.id = 'selection-toolbar';
  toolbar.innerHTML = `
    <button data-action="highlight" aria-label="Highlight">${Icons.highlight} Highlight</button>
    <button data-action="note" aria-label="Add note">${Icons.note} Note</button>
    <button data-action="copy" aria-label="Copy text">${Icons.copy} Copy</button>
  `;
  document.body.appendChild(toolbar);

  // Position above the selection, centered
  const tw = toolbar.offsetWidth;
  const th = toolbar.offsetHeight;
  let left = selRect.left + selRect.width / 2 - tw / 2;
  let top = selRect.top - th - 8;

  // Keep within viewport
  left = Math.max(8, Math.min(left, window.innerWidth - tw - 8));
  if (top < 8) top = selRect.bottom + 8;

  toolbar.style.left = left + 'px';
  toolbar.style.top = top + 'px';

  toolbar.addEventListener('click', (e) => {
    const btn = e.target.closest('button[data-action]');
    if (!btn) return;
    e.stopPropagation();
    handleSelectionAction(btn.dataset.action);
  });

  // Dismiss on outside click/scroll
  setTimeout(() => {
    document.addEventListener('pointerdown', _dismissOnOutside);
    document.addEventListener('scroll', _dismissOnScroll, { capture: true });
  }, 100);
}

function _dismissOnOutside(e) {
  const toolbar = document.getElementById('selection-toolbar');
  if (toolbar && !toolbar.contains(e.target)) dismissSelectionToolbar();
}
function _dismissOnScroll() { dismissSelectionToolbar(); }

function dismissSelectionToolbar() {
  const toolbar = document.getElementById('selection-toolbar');
  if (toolbar) toolbar.remove();
  document.removeEventListener('pointerdown', _dismissOnOutside);
  document.removeEventListener('scroll', _dismissOnScroll, { capture: true });
  // Clear selection to remove blue highlights from text layer
  window.getSelection()?.removeAllRanges();
}

function handleSelectionAction(action) {
  const selection = window.getSelection();
  if (!selection || selection.isCollapsed) { dismissSelectionToolbar(); return; }

  const selectedText = selection.toString().trim();
  if (!selectedText) { dismissSelectionToolbar(); return; }

  const range = selection.getRangeAt(0);
  const startEl = range.startContainer.nodeType === Node.TEXT_NODE ? range.startContainer.parentElement : range.startContainer;
  const textLayer = startEl?.closest('.text-layer');
  const pageWrapper = textLayer?.closest('.page-wrapper');
  if (!pageWrapper) { dismissSelectionToolbar(); return; }

  const pageNum = parseInt(pageWrapper.dataset.page);
  if (!pageNum) { dismissSelectionToolbar(); return; }

  // Get rects relative to the page wrapper, filtering out tiny/empty ones
  const wrapperRect = pageWrapper.getBoundingClientRect();
  const wW = wrapperRect.width;
  const wH = wrapperRect.height;
  const rawRects = Array.from(range.getClientRects());
  const relativeRects = rawRects
    .filter(r => r.width > 2 && r.height > 2)
    .map(r => ({
      xPct: Math.max(0, (r.left - wrapperRect.left) / wW),
      yPct: Math.max(0, (r.top - wrapperRect.top) / wH),
      widthPct: Math.min(1, r.width / wW),
      heightPct: Math.min(1, r.height / wH),
    }))
    .filter(r => r.widthPct > 0.001 && r.heightPct > 0.001);

  if (relativeRects.length === 0) { dismissSelectionToolbar(); return; }

  dismissSelectionToolbar();

  if (action === 'highlight') {
    addAnnotation('highlight', pageNum, { text: selectedText, rects: relativeRects });
    renderHighlightsForPage(pageNum, pageWrapper);
    showToast('Highlighted');
  } else if (action === 'note') {
    showNoteDialog(selectedText, (noteText) => {
      addAnnotation('note', pageNum, { text: selectedText, content: noteText, rects: relativeRects });
      renderHighlightsForPage(pageNum, pageWrapper);
      showToast('Note saved');
    });
  } else if (action === 'copy') {
    navigator.clipboard?.writeText(selectedText).then(() => showToast('Copied'));
  }
}

// ===== FREEHAND DRAWING =====
function renderFreehandForPage(pageNum, wrapper) {
  const existing = wrapper.querySelector('.freehand-canvas');
  if (existing) existing.remove();

  const state = store.getState();
  const docId = state.currentDoc?.id;
  const docAnnos = state.annotations[docId] || [];
  const freehandAnnos = docAnnos.filter(a => a.page === pageNum && a.type === 'freehand' && a.points);

  if (freehandAnnos.length === 0) return;

  const cvs = document.createElement('canvas');
  cvs.className = 'freehand-canvas';
  cvs.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;';
  cvs.width = wrapper.clientWidth * (window.devicePixelRatio || 1);
  cvs.height = wrapper.clientHeight * (window.devicePixelRatio || 1);
  const ctx = cvs.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const wW = wrapper.clientWidth;
  const wH = wrapper.clientHeight;

  const colorMap = {
    yellow: 'rgba(255,213,79,0.7)', green: 'rgba(102,187,106,0.7)',
    blue: 'rgba(66,165,245,0.7)', pink: 'rgba(240,98,146,0.7)', purple: 'rgba(171,130,255,0.7)'
  };

  for (const anno of freehandAnnos) {
    if (anno.points.length < 2) continue;
    ctx.beginPath();
    ctx.strokeStyle = colorMap[anno.color] || colorMap.yellow;
    ctx.lineWidth = 2 * dpr;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    const first = anno.points[0];
    ctx.moveTo(first.xPct * wW * dpr, first.yPct * wH * dpr);
    for (let i = 1; i < anno.points.length; i++) {
      const pt = anno.points[i];
      ctx.lineTo(pt.xPct * wW * dpr, pt.yPct * wH * dpr);
    }
    ctx.stroke();
  }

  wrapper.appendChild(cvs);
}

function setupDrawingForPage(pageNum, wrapper) {
  const existingDraw = wrapper.querySelector('.drawing-canvas');
  if (existingDraw) existingDraw.remove();

  // Only create if pen mode
  const state = store.getState();
  if (state.annotationMode !== 'pen') return;

  const drawCvs = document.createElement('canvas');
  drawCvs.className = 'drawing-canvas';
  drawCvs.width = wrapper.clientWidth * (window.devicePixelRatio || 1);
  drawCvs.height = wrapper.clientHeight * (window.devicePixelRatio || 1);
  const ctx = drawCvs.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const wW = wrapper.clientWidth;
  const wH = wrapper.clientHeight;

  let drawing = false;
  let currentPath = [];

  const colorMap = {
    yellow: 'rgba(255,213,79,0.8)', green: 'rgba(102,187,106,0.8)',
    blue: 'rgba(66,165,245,0.8)', pink: 'rgba(240,98,146,0.8)', purple: 'rgba(171,130,255,0.8)'
  };

  drawCvs.addEventListener('pointerdown', (e) => {
    drawing = true;
    const rect = drawCvs.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    currentPath = [{ xPct: x / wW, yPct: y / wH }];
    ctx.beginPath();
    ctx.strokeStyle = colorMap[store.getState().highlightColor] || colorMap.yellow;
    ctx.lineWidth = 2 * dpr;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.moveTo(x * dpr, y * dpr);
    drawCvs.setPointerCapture(e.pointerId);
  });

  drawCvs.addEventListener('pointermove', (e) => {
    if (!drawing) return;
    const rect = drawCvs.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    currentPath.push({ xPct: x / wW, yPct: y / wH });
    ctx.lineTo(x * dpr, y * dpr);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x * dpr, y * dpr);
  });

  drawCvs.addEventListener('pointerup', () => {
    if (!drawing) return;
    drawing = false;
    if (currentPath.length > 1) {
      addAnnotation('freehand', pageNum, {
        points: currentPath,
        color: store.getState().highlightColor,
      });
      // Re-render freehand layer
      renderFreehandForPage(pageNum, wrapper);
    }
    // Clear drawing canvas
    ctx.clearRect(0, 0, drawCvs.width, drawCvs.height);
  });

  wrapper.appendChild(drawCvs);
}

// ===== EVENT HANDLERS =====
function attachLibraryEvents() {
  document.getElementById('btn-open-file')?.addEventListener('click', promptFileOpen);

  document.getElementById('btn-settings-lib')?.addEventListener('click', () => {
    store.setState({ settingsOpen: true });
  });

  // Doc card clicks
  document.querySelectorAll('.doc-card').forEach(card => {
    card.addEventListener('click', (e) => {
      // Ignore if delete button was clicked
      if (e.target.closest('.doc-card-delete')) return;
      const docId = card.dataset.docId;
      handleOpenFromLibrary(docId);
    });
  });

  // Doc card delete buttons
  document.querySelectorAll('.doc-card-delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const docId = btn.dataset.deleteId;
      if (confirm('Remove this document from your library?')) {
        deleteDocument(docId);
      }
    });
  });

  // Library search
  document.getElementById('lib-search-input')?.addEventListener('input', (e) => {
    const query = e.target.value.toLowerCase();
    document.querySelectorAll('.doc-card').forEach(card => {
      const title = card.querySelector('.doc-card-title')?.textContent?.toLowerCase() || '';
      card.style.display = title.includes(query) ? '' : 'none';
    });
  });

  // Drag & Drop
  setupDragDrop();
  attachSettingsEvents();
}

function setupDragDrop() {
  document.addEventListener('dragover', (e) => { e.preventDefault(); store.setState({ isDragging: true }); });
  document.addEventListener('dragleave', (e) => {
    if (e.relatedTarget === null) store.setState({ isDragging: false });
  });
  document.addEventListener('drop', (e) => {
    e.preventDefault();
    store.setState({ isDragging: false });
    const file = e.dataTransfer.files[0];
    if (file) handleFileOpen(file);
  });
}

function attachReaderEvents() {
  document.getElementById('btn-back')?.addEventListener('click', () => {
    saveReadingProgress();
    store.setState({ view: 'library', sidePanel: false, searchOpen: false, focusMode: false, annotationMode: null });
  });

  document.getElementById('btn-sidebar')?.addEventListener('click', () => {
    store.setState({ sidePanel: !store.getState().sidePanel });
  });

  // Mobile sidebar backdrop
  document.getElementById('sidebar-backdrop')?.addEventListener('click', () => {
    store.setState({ sidePanel: false });
  });

  document.getElementById('btn-zoom-in')?.addEventListener('click', () => {
    const z = Math.min(store.getState().zoom + 0.15, 4);
    store.setState({ zoom: z });
    renderVisiblePages();
  });

  document.getElementById('btn-zoom-out')?.addEventListener('click', () => {
    const z = Math.max(store.getState().zoom - 0.15, 0.3);
    store.setState({ zoom: z });
    renderVisiblePages();
  });

  document.getElementById('btn-search')?.addEventListener('click', () => {
    store.setState({ searchOpen: !store.getState().searchOpen });
  });

  document.getElementById('btn-bookmark')?.addEventListener('click', toggleBookmark);
  document.getElementById('btn-focus')?.addEventListener('click', () => {
    store.setState({ focusMode: !store.getState().focusMode });
  });
  document.getElementById('btn-ruler')?.addEventListener('click', () => {
    store.setState({ showRuler: !store.getState().showRuler });
  });
  document.getElementById('btn-settings')?.addEventListener('click', () => {
    store.setState({ settingsOpen: true });
  });

  document.getElementById('page-slider')?.addEventListener('input', (e) => {
    goToPage(parseInt(e.target.value));
  });

  // Side panel tabs
  document.querySelectorAll('.sp-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      store.setState({ sidePanelTab: tab.dataset.sptab });
    });
  });

  document.getElementById('sp-content')?.addEventListener('click', (e) => {
    const item = e.target.closest('[data-page]');
    if (item) goToPage(parseInt(item.dataset.page));
    const removeBtn = e.target.closest('[data-remove-bm]');
    if (removeBtn) {
      e.stopPropagation();
      removeBookmark(parseInt(removeBtn.dataset.removeBm));
    }
  });

  // Search
  const searchInput = document.getElementById('search-input');
  let searchTimeout;
  searchInput?.addEventListener('input', (e) => {
    clearTimeout(searchTimeout);
    const query = e.target.value;
    store.setState({ searchQuery: query });
    searchTimeout = setTimeout(async () => {
      if (query.length >= 2) {
        const results = await engine.searchText(query);
        store.setState({ searchResults: results });
      } else {
        store.setState({ searchResults: [] });
      }
    }, 300);
  });

  document.getElementById('btn-close-search')?.addEventListener('click', () => {
    store.setState({ searchOpen: false, searchQuery: '', searchResults: [] });
  });

  document.getElementById('search-results')?.addEventListener('click', (e) => {
    const item = e.target.closest('[data-page]');
    if (item) goToPage(parseInt(item.dataset.page));
  });

  // Annotation FAB (menu is handled via direct DOM in updateAnnoMenu)
  document.getElementById('btn-anno-fab')?.addEventListener('click', () => {
    const s = store.getState();
    if (s.annotationMode) {
      store.setState({ annotationMode: null, annoMenuOpen: false });
    } else {
      store.setState({ annoMenuOpen: !s.annoMenuOpen });
    }
  });

  // Scroll-driven lazy rendering
  const readingCanvas = document.getElementById('reading-canvas');
  let scrollRaf = null;
  readingCanvas?.addEventListener('scroll', () => {
    if (scrollRaf) cancelAnimationFrame(scrollRaf);
    scrollRaf = requestAnimationFrame(() => {
      updateCurrentPageFromScroll();
      if (store.getState().continuousScroll) renderVisiblePagesLazy();
    });
  }, { passive: true });

  // Keyboard
  document.addEventListener('keydown', handleKeyboard);

  // Ruler
  if (store.getState().showRuler) {
    document.addEventListener('mousemove', (e) => {
      if (store.getState().showRuler) {
        const r = document.querySelector('.reading-ruler');
        if (r) r.style.top = e.clientY + 'px';
      }
    });
  }

  // Pinch-to-zoom
  setupPinchZoom(readingCanvas);

  // Swipe navigation (single-page mode)
  setupSwipeNavigation(readingCanvas);

  // Render pages — defer to next frame so the browser has laid out the DOM
  if (store.getState().pdfDoc && !store.getState().loading) {
    // Reset layout tracking so placeholders get built fresh
    _builtScale = null;
    requestAnimationFrame(() => {
      renderVisiblePages(true);
      if (store.getState().sidePanel && store.getState().sidePanelTab === 'thumbnails') {
        setTimeout(renderThumbnails, 200);
      }
    });
  }

  attachSettingsEvents();
  setupDragDrop();

  // Restore annotation menu if it was open before re-render
  const currentState = store.getState();
  if (currentState.annoMenuOpen) {
    updateAnnoMenu(currentState);
  }
}

function refreshDrawingCanvases() {
  for (const p of renderedPages) {
    const wrapper = document.getElementById(`page-wrap-${p}`);
    if (wrapper) setupDrawingForPage(p, wrapper);
  }
}

function attachSettingsEvents() {
  document.getElementById('modal-overlay')?.addEventListener('click', (e) => {
    if (e.target.id === 'modal-overlay') store.setState({ settingsOpen: false });
  });
  document.getElementById('btn-close-settings')?.addEventListener('click', () => {
    store.setState({ settingsOpen: false });
  });
  document.querySelectorAll('.theme-option[data-theme]').forEach(btn => {
    btn.addEventListener('click', () => store.setTheme(btn.dataset.theme));
  });
  document.getElementById('toggle-scroll')?.addEventListener('click', () => {
    store.setState({ continuousScroll: !store.getState().continuousScroll });
    if (store.getState().view === 'reader') renderVisiblePages();
  });
  document.getElementById('toggle-annobar')?.addEventListener('click', () => {
    store.setState({ showAnnotationBar: !store.getState().showAnnotationBar });
  });
  document.getElementById('toggle-ruler')?.addEventListener('click', () => {
    store.setState({ showRuler: !store.getState().showRuler });
  });
}

// ===== ANNOTATION MENU (direct DOM) =====
function updateAnnoMenu(state) {
  const existing = document.getElementById('anno-menu');
  const fab = document.getElementById('btn-anno-fab');

  if (!state.annoMenuOpen) {
    // Close menu
    if (existing) existing.remove();
    if (fab) {
      fab.classList.toggle('active', !!state.annotationMode);
      fab.innerHTML = state.annotationMode ? Icons.x : Icons.pen;
    }
    return;
  }

  // Open menu — create it
  if (existing) existing.remove();

  const colors = ['yellow', 'green', 'blue', 'pink', 'purple'];
  const menu = document.createElement('div');
  menu.className = 'anno-menu';
  menu.id = 'anno-menu';
  menu.innerHTML = `
    <button class="anno-btn ${state.annotationMode === 'highlight' ? 'active' : ''}"
            id="btn-anno-highlight" title="Highlight" aria-label="Highlight">${Icons.highlight}</button>
    <button class="anno-btn ${state.annotationMode === 'underline' ? 'active' : ''}"
            id="btn-anno-underline" title="Underline" aria-label="Underline" style="text-decoration:underline;font-weight:700;font-size:16px">U</button>
    <button class="anno-btn ${state.annotationMode === 'note' ? 'active' : ''}"
            id="btn-anno-note" title="Note" aria-label="Note">${Icons.note}</button>
    <button class="anno-btn ${state.annotationMode === 'pen' ? 'active' : ''}"
            id="btn-anno-pen" title="Draw" aria-label="Draw">${Icons.pen}</button>
    <div class="anno-color-row">
      ${colors.map(c => `
        <div class="color-dot ${state.highlightColor === c ? 'active' : ''}"
             data-color="${c}" title="${c}" aria-label="${c} color"
             style="background: var(--highlight-${c})"></div>
      `).join('')}
    </div>
    <button class="anno-btn" id="btn-anno-undo" title="Undo" aria-label="Undo">${Icons.undo}</button>
  `;

  // Insert into the reader shell (same parent as FAB)
  const shell = fab?.closest('.reader-shell');
  if (shell) {
    shell.appendChild(menu);
  }

  // Attach menu event listeners
  attachAnnoMenuEvents();

  // Close menu when clicking outside
  setTimeout(() => {
    document.addEventListener('click', function _closeAnno(e) {
      const menu = document.getElementById('anno-menu');
      const fab = document.getElementById('btn-anno-fab');
      if (!menu) { document.removeEventListener('click', _closeAnno); return; }
      if (!menu.contains(e.target) && e.target !== fab && !fab?.contains(e.target)) {
        store.setState({ annoMenuOpen: false });
        document.removeEventListener('click', _closeAnno);
      }
    });
  }, 10);
}

function attachAnnoMenuEvents() {
  document.getElementById('btn-anno-highlight')?.addEventListener('click', () => {
    toggleAnnotationMode('highlight');
    store.setState({ annoMenuOpen: false });
  });
  document.getElementById('btn-anno-underline')?.addEventListener('click', () => {
    toggleAnnotationMode('underline');
    store.setState({ annoMenuOpen: false });
  });
  document.getElementById('btn-anno-note')?.addEventListener('click', () => {
    toggleAnnotationMode('note');
    store.setState({ annoMenuOpen: false });
  });
  document.getElementById('btn-anno-pen')?.addEventListener('click', () => {
    toggleAnnotationMode('pen');
    store.setState({ annoMenuOpen: false });
    refreshDrawingCanvases();
  });
  document.querySelectorAll('#anno-menu [data-color]').forEach(btn => {
    btn.addEventListener('click', () => store.setState({ highlightColor: btn.dataset.color }));
  });
  document.getElementById('btn-anno-undo')?.addEventListener('click', undoAnnotation);
}

// ===== MOBILE: PINCH-TO-ZOOM =====
function setupPinchZoom(el) {
  if (!el) return;
  let initialDistance = 0;
  let initialZoom = 1;
  let zoomTimeout;

  el.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      initialDistance = Math.sqrt(
        (e.touches[1].clientX - e.touches[0].clientX) ** 2 +
        (e.touches[1].clientY - e.touches[0].clientY) ** 2
      );
      initialZoom = store.getState().zoom;
    }
  }, { passive: true });

  el.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      const dist = Math.sqrt(
        (e.touches[1].clientX - e.touches[0].clientX) ** 2 +
        (e.touches[1].clientY - e.touches[0].clientY) ** 2
      );
      const scale = dist / initialDistance;
      const newZoom = Math.min(4, Math.max(0.3, initialZoom * scale));
      store.setState({ zoom: newZoom });

      // Update zoom display without full re-render
      const zd = document.getElementById('zoom-display');
      if (zd) zd.textContent = Math.round(newZoom * 100) + '%';
      const zi = document.getElementById('zoom-info');
      if (zi) zi.textContent = Math.round(newZoom * 100) + '%';

      clearTimeout(zoomTimeout);
      zoomTimeout = setTimeout(() => renderVisiblePages(), 200);
    }
  }, { passive: true });
}

// ===== MOBILE: SWIPE NAVIGATION =====
function setupSwipeNavigation(el) {
  if (!el) return;
  let startX = 0;
  let startY = 0;

  el.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
    }
  }, { passive: true });

  el.addEventListener('touchend', (e) => {
    if (store.getState().continuousScroll) return;
    const endX = e.changedTouches[0].clientX;
    const endY = e.changedTouches[0].clientY;
    const dx = endX - startX;
    const dy = endY - startY;

    if (Math.abs(dx) > 80 && Math.abs(dx) > Math.abs(dy) * 1.5) {
      if (dx < 0) goToPage(store.getState().currentPage + 1);
      else goToPage(store.getState().currentPage - 1);
    }
  }, { passive: true });
}

// ===== NAVIGATION =====
function goToPage(page) {
  const state = store.getState();
  page = Math.max(1, Math.min(page, state.totalPages));
  if (page === state.currentPage && state.continuousScroll) {
    const wrapper = document.getElementById(`page-wrap-${page}`);
    if (wrapper) wrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
    return;
  }
  store.setState({ currentPage: page });

  if (state.continuousScroll) {
    const wrapper = document.getElementById(`page-wrap-${page}`);
    if (wrapper) {
      wrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
      renderVisiblePagesLazy();
    } else {
      renderVisiblePages();
    }
  } else {
    renderVisiblePages();
  }
  saveReadingProgress();
  updateStatusBar(page);
}

function updateCurrentPageFromScroll() {
  const container = document.getElementById('reading-canvas');
  if (!container) return;

  const scrollTop = container.scrollTop + container.clientHeight / 3;

  for (const pos of pagePositions) {
    if (pos.top + pos.height > scrollTop) {
      if (pos.page !== store.getState().currentPage) {
        store.setState({ currentPage: pos.page });
        updateStatusBar(pos.page);
      }
      break;
    }
  }
}

function updateStatusBar(page) {
  const state = store.getState();
  const slider = document.getElementById('page-slider');
  if (slider) slider.value = page;
  const pageInfo = document.getElementById('page-info');
  if (pageInfo) pageInfo.innerHTML = `Page <strong>${page}</strong> of ${state.totalPages}`;
  const readPct = document.getElementById('read-pct');
  if (readPct) readPct.textContent = `${Math.round((page / Math.max(state.totalPages, 1)) * 100)}% read`;
}

// ===== BOOKMARKS =====
function toggleBookmark() {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;

  const bookmarks = { ...state.bookmarks };
  if (!bookmarks[docId]) bookmarks[docId] = [];

  const idx = bookmarks[docId].indexOf(state.currentPage);
  if (idx >= 0) {
    bookmarks[docId].splice(idx, 1);
    showToast('Bookmark removed');
  } else {
    bookmarks[docId].push(state.currentPage);
    bookmarks[docId].sort((a, b) => a - b);
    showToast(`Page ${state.currentPage} bookmarked`);
  }

  store.setState({ bookmarks });
  store.persistBookmarks();

  // Update bookmark icon without full re-render
  const btn = document.getElementById('btn-bookmark');
  if (btn) {
    const isNowBookmarked = bookmarks[docId]?.includes(state.currentPage);
    btn.innerHTML = isNowBookmarked ? Icons.bookmarkFill : Icons.bookmark;
  }
}

function removeBookmark(page) {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const bookmarks = { ...state.bookmarks };
  if (bookmarks[docId]) {
    bookmarks[docId] = bookmarks[docId].filter(p => p !== page);
  }
  store.setState({ bookmarks });
  store.persistBookmarks();
  showToast('Bookmark removed');
}

// ===== ANNOTATIONS =====
function toggleAnnotationMode(mode) {
  const current = store.getState().annotationMode;
  const newMode = current === mode ? null : mode;
  store.setState({ annotationMode: newMode });
  // Toggle crosshair cursor when in note mode
  const canvas = document.querySelector('.reading-canvas');
  if (canvas) {
    canvas.classList.toggle('note-mode', newMode === 'note');
  }
}

function addAnnotation(type, page, data) {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const annotations = { ...state.annotations };
  if (!annotations[docId]) annotations[docId] = [];
  annotations[docId].push({
    id: generateId(), type, page,
    color: state.highlightColor,
    created: Date.now(),
    ...data
  });
  store.setState({ annotations, undoStack: [] }); // Clear redo on new annotation
  store.persistAnnotations();
}

function undoAnnotation() {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const annotations = { ...state.annotations };
  const undoStack = [...(state.undoStack || [])];
  if (annotations[docId]?.length > 0) {
    const removed = annotations[docId].pop();
    undoStack.push(removed);
    store.setState({ annotations, undoStack });
    store.persistAnnotations();
    showToast('Annotation undone');
    // Refresh highlights on the affected page
    const wrapper = document.getElementById(`page-wrap-${removed.page}`);
    if (wrapper) {
      renderHighlightsForPage(removed.page, wrapper);
      renderFreehandForPage(removed.page, wrapper);
    }
  }
}

function redoAnnotation() {
  const state = store.getState();
  const docId = state.currentDoc?.id;
  if (!docId) return;
  const undoStack = [...(state.undoStack || [])];
  if (undoStack.length === 0) return;
  const annotations = { ...state.annotations };
  if (!annotations[docId]) annotations[docId] = [];
  const restored = undoStack.pop();
  annotations[docId].push(restored);
  store.setState({ annotations, undoStack });
  store.persistAnnotations();
  showToast('Annotation restored');
  const wrapper = document.getElementById(`page-wrap-${restored.page}`);
  if (wrapper) {
    renderHighlightsForPage(restored.page, wrapper);
    renderFreehandForPage(restored.page, wrapper);
  }
}

// ===== READING PROGRESS =====
function saveReadingProgress() {
  const state = store.getState();
  if (!state.currentDoc) return;
  const progress = state.currentPage / Math.max(state.totalPages, 1);
  const docs = state.documents.map(d =>
    d.id === state.currentDoc.id
      ? { ...d, lastPage: state.currentPage, progress, lastOpened: Date.now() }
      : d
  );
  store.setState({
    documents: docs,
    currentDoc: { ...state.currentDoc, lastPage: state.currentPage, progress }
  });
  store.persistDocs();
}

// ===== KEYBOARD SHORTCUTS =====
function handleKeyboard(e) {
  const state = store.getState();
  if (state.view !== 'reader') return;
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

  switch (e.key) {
    case 'ArrowRight': case 'ArrowDown':
      if (!state.continuousScroll) { e.preventDefault(); goToPage(state.currentPage + 1); }
      break;
    case 'ArrowLeft': case 'ArrowUp':
      if (!state.continuousScroll) { e.preventDefault(); goToPage(state.currentPage - 1); }
      break;
    case 'Home': e.preventDefault(); goToPage(1); break;
    case 'End': e.preventDefault(); goToPage(state.totalPages); break;
    case 'f':
      if (e.ctrlKey || e.metaKey) { e.preventDefault(); store.setState({ searchOpen: true }); }
      break;
    case 'b':
      if (e.ctrlKey || e.metaKey) { e.preventDefault(); toggleBookmark(); }
      break;
    case 'Escape':
      if (state.searchOpen) store.setState({ searchOpen: false });
      else if (state.settingsOpen) store.setState({ settingsOpen: false });
      else if (state.focusMode) store.setState({ focusMode: false });
      else if (state.annotationMode) store.setState({ annotationMode: null });
      break;
    case '+': case '=':
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        store.setState({ zoom: Math.min(state.zoom + 0.15, 4) });
        renderVisiblePages();
      }
      break;
    case '-':
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        store.setState({ zoom: Math.max(state.zoom - 0.15, 0.3) });
        renderVisiblePages();
      }
      break;
  }
}

// ===== SMART STATE SUBSCRIBER =====
store.subscribe((state, prev) => {
  // Full re-render only on view transitions
  if (state.view !== currentView) {
    currentView = state.view;
    renderApp();
    return;
  }

  if (state.view === 'library') {
    // Library: only full re-render for structural changes
    if (state.documents !== prev.documents || state.isDragging !== prev.isDragging) {
      renderApp();
      return;
    }
    // Settings modal toggle
    if (state.settingsOpen !== prev.settingsOpen) {
      renderApp();
      return;
    }
    // Toast
    if (state.toast !== prev.toast) {
      const existingToast = document.querySelector('.toast');
      if (existingToast) existingToast.remove();
      if (state.toast) {
        const t = document.createElement('div');
        t.className = 'toast';
        t.setAttribute('role', 'status');
        t.textContent = state.toast;
        document.querySelector('.app-shell')?.appendChild(t);
      }
    }
    return;
  }

  // Reader: targeted updates
  if (state.view === 'reader') {
    // Loading state changed — swap spinner ↔ page container
    if (state.loading !== prev.loading) {
      renderApp();
      return;
    }

    // Loading progress — update the bar width directly
    if (state.loadProgress !== prev.loadProgress && state.loading) {
      const bar = document.querySelector('.load-progress-bar');
      if (bar) bar.style.width = (state.loadProgress || 5) + '%';
      return;
    }

    // Settings / search modals — full re-render
    if (state.settingsOpen !== prev.settingsOpen ||
        state.searchOpen !== prev.searchOpen ||
        state.sidePanel !== prev.sidePanel ||
        state.sidePanelTab !== prev.sidePanelTab ||
        state.showRuler !== prev.showRuler) {
      renderApp();
      return;
    }

    // Annotation menu — direct DOM manipulation (no re-render)
    if (state.annoMenuOpen !== prev.annoMenuOpen) {
      updateAnnoMenu(state);
    }

    // Focus mode toggle
    if (state.focusMode !== prev.focusMode) {
      const shell = document.querySelector('.app-shell');
      if (shell) shell.classList.toggle('focus-mode', state.focusMode);
    }

    // Zoom display
    if (state.zoom !== prev.zoom) {
      const zd = document.getElementById('zoom-display');
      if (zd) zd.textContent = Math.round(state.zoom * 100) + '%';
      const zi = document.getElementById('zoom-info');
      if (zi) zi.textContent = Math.round(state.zoom * 100) + '%';
    }

    // Annotation mode toggle — update FAB icon + menu button active states
    if (state.annotationMode !== prev.annotationMode) {
      const fab = document.getElementById('btn-anno-fab');
      if (fab) {
        fab.classList.toggle('active', !!state.annotationMode);
        fab.innerHTML = state.annotationMode ? Icons.x : Icons.pen;
      }
      ['highlight', 'underline', 'note', 'pen'].forEach(m => {
        const btn = document.getElementById(`btn-anno-${m}`);
        if (btn) btn.classList.toggle('active', state.annotationMode === m);
      });
    }

    // Highlight color
    if (state.highlightColor !== prev.highlightColor) {
      document.querySelectorAll('[data-color]').forEach(dot => {
        dot.classList.toggle('active', dot.dataset.color === state.highlightColor);
      });
    }

    // Toast
    if (state.toast !== prev.toast) {
      const existingToast = document.querySelector('.toast');
      if (existingToast) existingToast.remove();
      if (state.toast) {
        const t = document.createElement('div');
        t.className = 'toast';
        t.setAttribute('role', 'status');
        t.textContent = state.toast;
        document.querySelector('.app-shell')?.appendChild(t);
      }
    }
  }
});

// ===== INITIALIZE =====
setupTextSelectionHandler();
setupTapToNote();
setupLongPressHandler();

window.addEventListener('pdf-loaded', () => {
  renderVisiblePages(true);
  if (store.getState().sidePanel && store.getState().sidePanelTab === 'thumbnails') {
    setTimeout(renderThumbnails, 300);
  }

});

let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    if (store.getState().view === 'reader' && store.getState().pdfDoc) {
      renderVisiblePages();
    }
  }, 250);
});

// Service Worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').then(reg => {
      reg.addEventListener('updatefound', () => {
        const newWorker = reg.installing;
        newWorker?.addEventListener('statechange', () => {
          if (newWorker.state === 'activated') {
            showToast('App updated! Refresh for the latest version.');
          }
        });
      });
    }).catch((err) => {
      console.warn('Service worker registration failed:', err);
    });
  });
}

// Capacitor back button
if (window.Capacitor?.Plugins?.App) {
  window.Capacitor.Plugins.App.addListener('backButton', () => {
    const state = store.getState();
    if (state.settingsOpen) store.setState({ settingsOpen: false });
    else if (state.searchOpen) store.setState({ searchOpen: false });
    else if (state.view === 'reader') {
      saveReadingProgress();
      store.setState({ view: 'library', sidePanel: false, searchOpen: false, focusMode: false });
    } else {
      window.Capacitor.Plugins.App.exitApp();
    }
  });
}

// Initial render
renderApp();
</script>
</body>
</html>
